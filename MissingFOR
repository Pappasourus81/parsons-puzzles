<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Code Shuffler â€“ FOR Loops (Fill the Blanks)</title>
<style>
  :root{
    --bg:#ffffff; --accent:#0066cc; --ok:#d4f7d9; --bad:#ffd6d6;
    --panel:#f8f9fb; --muted:#666; --token-border:#e0e6ef;
  }
  body{ font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:18px; background:var(--bg); color:#111; }
  h1{ margin:0 0 12px 0; font-size:20px; }
  .meta{ color:#444; margin-bottom:12px; }
  .panel{ background:var(--panel); padding:12px; border-radius:10px; margin-bottom:12px; }
  .desc-box{ padding:10px; border-radius:8px; background:#fff; border:1px solid #d1d7df; margin-bottom:10px; }
  .code-area{ font-family: "Courier New", monospace; background:#fff; padding:10px; border-radius:8px; border:1px dashed #ccc; min-height:110px; }
  .code-line{ padding:6px 4px; white-space:pre-wrap; }
  .blank{ display:inline-flex; align-items:center; justify-content:center; min-width:64px; padding:4px 8px; margin:0 4px; background:#f2f6fb; border-radius:4px; border:1px dashed #9fb8e6; cursor:pointer; outline:none; color:#111; font-weight:600; }
  .blank.filled{ background:#fff; border-style:solid; border-color:var(--token-border); }
  .blank.correct{ background:var(--ok); border-color:#2a9a4a; }
  .blank.incorrect{ background:var(--bad); border-color:#c44; }
  .bank{ display:flex; flex-wrap:wrap; gap:8px; padding:10px; margin-top:10px; background:transparent; }
  .token{ background:#fff; border:1px solid var(--token-border); padding:6px 10px; border-radius:8px; cursor:grab; user-select:none; display:inline-flex; align-items:center; justify-content:center; min-width:40px; color:#111; font-weight:600; }
  .token[aria-pressed="true"]{ outline:3px solid rgba(0,102,204,0.18); box-shadow:0 2px 6px rgba(0,0,0,0.06); }
  .controls{ display:flex; gap:8px; margin-top:12px; align-items:center; }
  button.action{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  button.secondary{ background:#666; color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  #message{ margin-top:10px; font-weight:600; }
  .keyboard-hint{ color:var(--muted); font-size:13px; margin-top:6px; }
  @media (max-width:700px){ .bank{ gap:6px; } .blank{ min-width:44px; } .token{ min-width:32px; padding:6px 8px;} }
</style>
</head>
<body>
  <h1>Code Shuffler â€“ FOR Loops (Fill the Blanks)</h1>
  <div class="meta">Place the correct token into each blank. Use drag & drop, or keyboard: Tab to token â†’ Enter to pick â†’ Tab to blank â†’ Enter to place.</div>

  <div class="panel">
    <div id="desc" class="desc-box">Select a puzzle to see its description</div>

    <div class="code-area" id="codeArea" aria-live="polite"></div>

    <div class="bank" id="bank"></div>

    <div class="keyboard-hint">Tip: you can also click a token to select it, then click a blank to place it.</div>

    <div class="controls">
      <button id="submitBtn" class="action">Submit</button>
      <button id="resetBtn" class="secondary">Reset (reshuffle)</button>
      <button id="nextBtn" class="action">Next Puzzle</button>
      <div style="margin-left:auto;">
        <label style="font-size:13px;color:#333">Puzzle:
          <select id="puzzleSelect" style="margin-left:8px; padding:6px; border-radius:6px;"></select>
        </label>
      </div>
    </div>

    <div id="message" role="status"></div>
  </div>

<script>
/*
 Fixed and improved fill-in-the-blanks FOR-loop page.
 Each puzzle:
  - title, description
  - lines: strings with blanks like ___1___
  - answers: correct tokens for blanks in order
  - bank: tokens including distractors
*/

const puzzles = [
  {
    title: "Simple FOR output 1 to 3",
    description: "No input. Use a FOR loop to output numbers 1 to 3. Example output: 1 2 3.",
    lines: [
      "___1___ i = ___2___ TO ___3___ DO",
      "OUTPUT ___4___",
      "NEXT ___5___"
    ],
    answers: ["FOR","1","3","i","i"],
    bank: ["FOR","NEXT","i","1","3","TO","STEP","OUTPUT","j","2"]
  },
  {
    title: "FOR with STEP 3",
    description: "No input. Use STEP to output every third number from 1 to 10. Example: 1 4 7 10.",
    lines: [
      "FOR i = ___1___ TO ___2___ ___3___ ___4___ DO",
      "OUTPUT i",
      "NEXT i"
    ],
    answers: ["1","10","STEP","3"],
    bank: ["1","10","STEP","3","2","TO","OUTPUT","i","NEXT","STEP 3"]
  },
  {
    title: "Descending FOR loop",
    description: "No input. Loop from 5 down to 1 using a negative STEP. Example: 5 4 3 2 1.",
    lines: [
      "FOR k = ___1___ TO ___2___ ___3___ ___4___ DO",
      "OUTPUT k",
      "NEXT k"
    ],
    answers: ["5","1","STEP","-1"],
    bank: ["5","1","-1","STEP","TO","k","FOR","i","NEXT","OUTPUT"]
  },
  {
    title: "Sum a few values",
    description: "Input: ask the user for 3 numbers, add them to total and output the result after the loop. Example: entering 1,2,3 outputs 6.",
    lines: [
      "total = ___1___",
      "FOR i = ___2___ TO ___3___ DO",
      "INPUT n",
      "total = total ___4___ n",
      "NEXT i",
      "OUTPUT total"
    ],
    answers: ["0","1","3","+"],
    bank: ["0","+","-","1","3","FOR","INPUT","OUTPUT","n","NEXT"]
  },
  {
    title: "Double input values",
    description: "Input: the user enters 4 numbers. For each number output twice its value. Example: entering 2 prints 4.",
    lines: [
      "FOR i = ___1___ TO ___2___ DO",
      "INPUT value",
      "OUTPUT value ___3___ 2",
      "NEXT i"
    ],
    answers: ["1","4","*"],
    bank: ["1","4","*","/","+","-","INPUT","OUTPUT","value","NEXT"]
  },
  {
    title: "Output only even numbers",
    description: "Input: the user enters 4 numbers. Output only those that are even using MOD. Example: entering 2,3,4,5 outputs 2 and 4.",
    lines: [
      "FOR i = ___1___ TO ___2___ DO",
      "INPUT num",
      "IF num ___3___ 2 = 0 THEN",
      "OUTPUT num",
      "ENDIF",
      "NEXT i"
    ],
    answers: ["1","4","MOD"],
    bank: ["1","4","MOD","DIV","%","IF","THEN","ENDIF","OUTPUT","num"]
  },
  {
    title: "Count values above threshold",
    description: "Input: user enters 5 values. Count how many are greater than 10 and output the count after the loop. Example: entering 12,9,15,6,11 outputs 3.",
    lines: [
      "count = ___1___",
      "FOR i = ___2___ TO ___3___ DO",
      "INPUT v",
      "IF v > ___4___ THEN",
      "count = count + 1",
      "ENDIF",
      "NEXT i",
      "OUTPUT count"
    ],
    answers: ["0","1","5","10"],
    bank: ["0","1","5","10","count","v","INPUT","OUTPUT","THEN","IF"]
  },
  {
    title: "FOR with variable step expression",
    description: "No input. Use a variable stepSize in the STEP clause to progress the loop. Example: if stepSize=2 and upper bound 5, output 1 3 5.",
    lines: [
      "stepSize = 2",
      "FOR i = ___1___ TO ___2___ STEP ___3___ DO",
      "OUTPUT i",
      "NEXT i"
    ],
    answers: ["1","5","stepSize"],
    bank: ["1","5","2","stepSize","STEP","FOR","OUTPUT","i","NEXT"]
  },
  {
    title: "NEXT variable mismatch (fix the loop variable)",
    description: "Attention to loop variable naming. Ensure NEXT uses the same variable name as FOR. Example output: 1 2 3.",
    lines: [
      "FOR index = ___1___ TO ___2___ DO",
      "OUTPUT index",
      "NEXT ___3___"
    ],
    answers: ["1","3","index"],
    bank: ["1","3","i","index","NEXT","FOR","OUTPUT","TO"]
  },
  {
    title: "Nested FOR to build pairs (small)",
    description: "No input. Use nested FOR loops to output pairs (i,j) for i=1..2 and j=1..3. Example output: 1,1 1,2 1,3 2,1 2,2 2,3.",
    lines: [
      "FOR i = ___1___ TO ___2___ DO",
      "FOR j = ___3___ TO ___4___ DO",
      "OUTPUT i , j",
      "NEXT j",
      "NEXT i"
    ],
    answers: ["1","2","1","3"],
    bank: ["1","2","3","j","i","FOR","NEXT","OUTPUT",",","TO"]
  }
];

// UI elements
const bankEl = document.getElementById('bank');
const codeArea = document.getElementById('codeArea');
const descEl = document.getElementById('desc');
const msgEl = document.getElementById('message');
const puzzleSelect = document.getElementById('puzzleSelect');

let currentIndex = 0;
let selectedToken = null; // {el, value}

// helpers
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}

function populatePuzzleSelect(){
  puzzles.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i+1}. ${p.title}`;
    puzzleSelect.appendChild(opt);
  });
}

// render bank tokens
function renderBank(tokens){
  bankEl.innerHTML = '';
  const copy = tokens.slice();
  shuffleArray(copy);
  copy.forEach(tok=>{
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'token';
    btn.textContent = tok;
    btn.setAttribute('aria-pressed','false');
    btn.draggable = true;
    btn.tabIndex = 0;
    btn.addEventListener('click', ()=> toggleSelectToken(btn, tok));
    btn.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleSelectToken(btn,tok); }});
    btn.addEventListener('dragstart', (e)=> e.dataTransfer.setData('text/plain', tok));
    bankEl.appendChild(btn);
  });
}

function toggleSelectToken(el, val){
  if(selectedToken && selectedToken.el === el){
    el.setAttribute('aria-pressed','false');
    selectedToken = null;
    return;
  }
  // clear previous
  document.querySelectorAll('.token[aria-pressed="true"]').forEach(b=>b.setAttribute('aria-pressed','false'));
  el.setAttribute('aria-pressed','true');
  selectedToken = {el, val};
}

// render code area with blanks
function renderCode(p){
  codeArea.innerHTML = '';
  p.lines.forEach(line=>{
    const lineDiv = document.createElement('div');
    lineDiv.className = 'code-line';

    // find blanks
    let last = 0;
    const re = /___(\d+)___/g;
    let m;
    while((m = re.exec(line)) !== null){
      const idx = m.index;
      const before = line.slice(last, idx);
      if(before) lineDiv.appendChild(document.createTextNode(before));
      const num = m[1];
      const span = document.createElement('button');
      span.type = 'button';
      span.className = 'blank';
      span.dataset.blank = num;
      span.dataset.filled = 'false';
      span.textContent = `___${num}___`;
      // drag/drop
      span.addEventListener('dragover', e => { e.preventDefault(); span.classList.add('dragover'); });
      span.addEventListener('dragleave', ()=> span.classList.remove('dragover'));
      span.addEventListener('drop', e => {
        e.preventDefault();
        span.classList.remove('dragover');
        const tok = e.dataTransfer.getData('text/plain');
        placeTokenInBlank(tok, span);
      });
      // click to place selected token
      span.addEventListener('click', ()=> {
        if(selectedToken) placeTokenInBlank(selectedToken.val, span);
      });
      span.addEventListener('keydown', (e)=> {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          if(selectedToken) placeTokenInBlank(selectedToken.val, span);
        }
      });
      lineDiv.appendChild(span);
      last = re.lastIndex;
    }
    const rest = line.slice(last);
    if(rest) lineDiv.appendChild(document.createTextNode(rest));
    codeArea.appendChild(lineDiv);
  });
}

// place token into blank (handles swapping/back to bank)
function placeTokenInBlank(tokenValue, blankEl){
  if(!blankEl) return;
  const wasFilled = blankEl.dataset.filled === 'true';
  const existingToken = wasFilled ? blankEl.dataset.token : null;

  // if tokenValue currently in another blank, swap
  const otherBlank = Array.from(document.querySelectorAll('.blank')).find(b => b.dataset.filled === 'true' && b.dataset.token === tokenValue);
  if(otherBlank){
    // swap token in otherBlank with token in this blank (or move)
    if(wasFilled){
      // swap values
      otherBlank.dataset.token = existingToken;
      otherBlank.textContent = existingToken;
      blankEl.dataset.token = tokenValue;
      blankEl.textContent = tokenValue;
      otherBlank.dataset.filled = 'true';
      blankEl.dataset.filled = 'true';
    } else {
      // move from other to this
      otherBlank.dataset.filled = 'false';
      otherBlank.dataset.token = '';
      otherBlank.textContent = `___${otherBlank.dataset.blank}___`;
      blankEl.dataset.token = tokenValue;
      blankEl.textContent = tokenValue;
      blankEl.dataset.filled = 'true';
    }
    // ensure bank reflects tokens (we'll rebuild bank from original list)
    rebuildBankFromPuzzle();
    clearSelection();
    return;
  }

  // find token button in bank (first matching)
  const btn = Array.from(bankEl.children).find(b=>b.textContent === tokenValue);
  if(!btn && !wasFilled) {
    // not available in bank and blank empty â€” do nothing
    return;
  }

  // if blank had a token, return it to bank
  if(wasFilled && existingToken){
    addTokenToBank(existingToken);
  }

  // set token into blank
  blankEl.dataset.token = tokenValue;
  blankEl.textContent = tokenValue;
  blankEl.dataset.filled = 'true';
  blankEl.classList.add('filled');

  // remove token from bank (first matching element)
  if(btn) btn.remove();
  // clear selection
  clearSelection();
}

function addTokenToBank(token){
  const b = document.createElement('button');
  b.type = 'button';
  b.className = 'token';
  b.textContent = token;
  b.setAttribute('aria-pressed','false');
  b.draggable = true;
  b.tabIndex = 0;
  b.addEventListener('click', ()=> toggleSelectToken(b, token));
  b.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggleSelectToken(b,token);} });
  b.addEventListener('dragstart', (e)=> e.dataTransfer.setData('text/plain', token));
  bankEl.appendChild(b);
}

function clearSelection(){
  document.querySelectorAll('.token[aria-pressed="true"]').forEach(x=>x.setAttribute('aria-pressed','false'));
  selectedToken = null;
}

// rebuild bank to original puzzle tokens (useful after swaps)
function rebuildBankFromPuzzle(){
  const p = puzzles[currentIndex];
  // collect currently placed tokens
  const placed = Array.from(document.querySelectorAll('.blank')).filter(b=>b.dataset.filled === 'true').map(b=>b.dataset.token);
  // start from original list and remove placed instances
  const copy = p.bank.slice();
  placed.forEach(t => {
    const idx = copy.indexOf(t);
    if(idx !== -1) copy.splice(idx,1);
  });
  renderBank(copy);
}

// render bank with given tokens array (used initially)
function renderBank(tokens){
  bankEl.innerHTML = '';
  const arr = tokens.slice();
  shuffleArray(arr);
  arr.forEach(tok=>{
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'token';
    b.textContent = tok;
    b.setAttribute('aria-pressed','false');
    b.draggable = true;
    b.tabIndex = 0;
    b.addEventListener('click', ()=> toggleSelectToken(b, tok));
    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleSelectToken(b,tok);} });
    b.addEventListener('dragstart', (e)=> e.dataTransfer.setData('text/plain', tok));
    bankEl.appendChild(b);
  });
}

// reset current puzzle: clear blanks, repopulate bank
function resetCurrent(){
  const p = puzzles[currentIndex];
  // clear blanks
  document.querySelectorAll('.blank').forEach(b=>{
    b.dataset.filled = 'false';
    b.dataset.token = '';
    b.classList.remove('filled','correct','incorrect');
    b.textContent = `___${b.dataset.blank}___`;
  });
  // repopulate bank from original list
  renderBank(p.bank.slice());
  clearSelection();
  msgEl.textContent = '';
}

// check answers
function checkAnswers(){
  const p = puzzles[currentIndex];
  const answers = p.answers.slice();
  const blanks = Array.from(document.querySelectorAll('.blank')).sort((a,b)=> Number(a.dataset.blank) - Number(b.dataset.blank));
  let allCorrect = true;
  blanks.forEach((b, i)=>{
    const placed = b.dataset.filled === 'true' ? b.dataset.token : '';
    const correct = answers[i] !== undefined ? answers[i] : '';
    if(correct === '' || correct === undefined || correct === null){
      // treat as not checked
      b.classList.remove('correct','incorrect');
      return;
    }
    if(placed === correct){
      b.classList.remove('incorrect'); b.classList.add('correct');
    } else {
      b.classList.remove('correct'); b.classList.add('incorrect');
      allCorrect = false;
    }
  });
  if(allCorrect){
    msgEl.textContent = 'All correct! Well done ðŸŽ‰'; msgEl.style.color = '#1a7f3a';
  } else {
    msgEl.textContent = 'Some blanks are incorrect â€” incorrect blanks are highlighted.'; msgEl.style.color = '#a00';
  }
}

// load puzzle
function loadPuzzle(index){
  if(index < 0 || index >= puzzles.length) index = 0;
  currentIndex = index;
  const p = puzzles[currentIndex];
  descEl.textContent = p.description;
  renderCode(p);
  renderBank(p.bank.slice());
  msgEl.textContent = '';
  clearSelection();
}

// navigation and events
document.getElementById('submitBtn').addEventListener('click', checkAnswers);
document.getElementById('resetBtn').addEventListener('click', resetCurrent);
document.getElementById('nextBtn').addEventListener('click', ()=> {
  currentIndex = (currentIndex + 1) % puzzles.length;
  puzzleSelect.value = currentIndex;
  loadPuzzle(currentIndex);
});
puzzleSelect.addEventListener('change', (e)=> loadPuzzle(Number(e.target.value)));

// init
populatePuzzleSelect();
loadPuzzle(0);
</script>
</body>
</html>
