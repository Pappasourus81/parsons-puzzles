<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Parsons — REPEAT UNTIL (Reorder mode)</title>
<style>
  :root{
    --bg:#f6f8fb; --card:#fff; --accent:#0568d6; --ok:#e6fbec; --bad:#ffecec;
    --border:#dfe7f2; --muted:#556;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); margin:20px; color:#122;}
  .container{max-width:960px;margin:0 auto;}
  header{display:flex;align-items:center;gap:16px;}
  h1{margin:0;font-size:20px;}
  .panel{background:var(--card);border:1px solid var(--border);padding:12px;border-radius:10px;margin-top:12px;}
  .desc-box{border-radius:8px;padding:10px;border:1px solid #e2e8f0;background:#fff;margin-bottom:12px;}
  .desc-title{font-weight:700;margin-bottom:6px;}
  .desc-list{margin:6px 0 0 18px;color:#123;}
  .example{font-family:monospace;background:#f3f9ff;padding:8px;border-radius:6px;border:1px solid #dbeeff;margin-top:8px;white-space:pre-wrap;}
  .code-box{min-height:160px;border:2px dashed var(--border);background:#fff;padding:12px;border-radius:8px;display:flex;flex-direction:column;gap:8px;}
  .block{user-select:none;padding:10px 12px;border-radius:8px;background:#f9fbff;border:1px solid #d0d9ef;cursor:grab;min-width:220px;box-shadow:0 1px 0 rgba(0,0,0,0.02);transition:transform .12s ease, background .18s;}
  .block.dragging{opacity:0.6;transform:scale(0.98);}
  .block.correct{background:var(--ok);border-color:#80d08a;}
  .block.incorrect{background:var(--bad);border-color:#f3a3a3;}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px;}
  button{padding:8px 12px;border-radius:8px;border:0;font-weight:700;cursor:pointer;}
  .btn-primary{background:var(--accent);color:white;}
  .btn-secondary{background:#657; color:#fff; opacity:0.95}
  .btn-ghost{background:#eef2f7;color:#223;border:1px solid #d6e0f4;}
  select{padding:6px;border-radius:8px;border:1px solid #d7e0f5;}
  #message{margin-top:10px;font-weight:700;color:#444;}
  @media (max-width:700px){
    .block{min-width:150px;}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Parsons — REPEAT UNTIL (Reorder mode)</h1>
    </header>

    <div class="panel" id="puzzlePanel">
      <div class="desc-box" id="descriptionBox">
        <div class="desc-title" id="descTitle">Select a puzzle</div>
        <ul class="desc-list" id="descBullets"></ul>
        <div id="exampleBox" class="example" style="display:none;"></div>
      </div>

      <div id="codeBox" class="code-box" aria-label="Scrambled code lines" tabindex="0"></div>

      <div class="controls" style="justify-content:flex-start;">
        <button id="submitBtn" class="btn-primary">Submit</button>
        <button id="revealHintBtn" class="btn-ghost">Reveal hint (3 left)</button>
        <button id="resetBtn" class="btn-secondary">Reset (Reshuffle)</button>
        <button id="nextBtn" class="btn-ghost">Next Puzzle</button>
        <div style="margin-left:auto;">
          <label> Puzzle:
            <select id="puzzleSelect"></select>
          </label>
        </div>
      </div>

      <div id="message"></div>
    </div>
  </div>

<script>
/*
 Updated Parsons reorder page with requested changes:
 1) Example area now shows an "Expected Output" heading.
 2) Lines support dragging — drop inserts the dragged line at the drop position, pushing subsequent lines down.
 3) Assignment uses '<-' instead of '=' where the line is an assignment (not comparisons).
 4) Puzzle 6 (age) description rewritten to explain behaviour without showing code.
 5) Puzzle 7 wording uses "greater than 50" rather than the symbol.
 6) All puzzles that request input now include an OUTPUT prompt line before the INPUT.
 7) Puzzle 10 (the last puzzle) instructions no longer give code; they describe behaviour (use 'Loop through...').
*/

const MAX_HINTS_PER_PUZZLE = 3;

const puzzles = [
  {
    title: "Count 1 to 5 with REPEAT UNTIL",
    bullets: ["No input — print numbers 1 to 5, each on its own line."],
    example: "1\n2\n3\n4\n5",
    lines: [
      "i <- 1",
      "REPEAT",
      "OUTPUT i",
      "i <- i + 1",
      "UNTIL i > 5"
    ]
  },
  {
    title: "Count 1 to 10 with counter",
    bullets: ["No input — loop from 1 to 10 using a counter variable."],
    example: "1..10 (each on its own line)",
    lines: [
      "count <- 1",
      "REPEAT",
      "OUTPUT count",
      "count <- count + 1",
      "UNTIL count > 10"
    ]
  },
  {
    title: "Stop on zero (input)",
    bullets: ["Ask the user for numbers repeatedly and stop when they enter 0."],
    example: "Input: 4, 2, 0 → loop stops when 0 is entered.",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter a number (0 to stop)\"",
      "INPUT n",
      "UNTIL n = 0"
    ]
  },
  {
    title: "Double until -1 (input & output)",
    bullets: ["Ask for numbers; output each doubled. Stop when the user enters -1."],
    example: "Input 3 → Output 6; Input -1 → stop",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter a number (-1 to stop)\"",
      "INPUT v",
      "IF v <> -1 THEN",
      "OUTPUT v * 2",
      "ENDIF",
      "UNTIL v = -1"
    ]
  },
  {
    title: "Positive or negative (stop on 0)",
    bullets: ["Ask for a number and print whether it's positive or negative; stop on 0."],
    example: "Input 3 → 'Positive'; input -1 → 'Negative'; 0 → stop",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter a number (0 to stop)\"",
      "INPUT n",
      "IF n > 0 THEN",
      "OUTPUT \"Positive\"",
      "ELSE",
      "OUTPUT \"Negative\"",
      "ENDIF",
      "UNTIL n = 0"
    ]
  },
  {
    title: "Age check (Adult/Child), stop with -1",
    bullets: [
      // rewritten to avoid giving the implementation away
      "Repeatedly ask for an age value.",
      "For each entered age, output whether that person should be classified as an adult or a child.",
      "A special sentinel value of -1 ends the loop."
    ],
    example: "Input 20 → 'Adult'; Input 12 → 'Child'; -1 → stop",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter age (-1 to stop)\"",
      "INPUT age",
      "IF age >= 18 THEN",
      "OUTPUT \"Adult\"",
      "ELSE",
      "OUTPUT \"Child\"",
      "ENDIF",
      "UNTIL age = -1"
    ]
  },
  {
    title: "Count scores greater than 50",
    bullets: ["Keep a counter for scores greater than 50; stop on -1 and output the count."],
    example: "Inputs 55,40,60,-1 → Output: 2",
    lines: [
      "count <- 0",
      "REPEAT",
      "OUTPUT \"Enter score (-1 to stop)\"",
      "INPUT score",
      "IF score > 50 THEN",
      "count <- count + 1",
      "ENDIF",
      "UNTIL score = -1",
      "OUTPUT count"
    ]
  },
  {
    title: "Password check until correct",
    bullets: ["Ask for a password until user enters \"Secret\"; then print Access granted."],
    example: "Input 'Secret' → 'Access granted'",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter password\"",
      "INPUT pw",
      "UNTIL pw = \"Secret\"",
      "OUTPUT \"Access granted\""
    ]
  },
  {
    title: "Print stars per request (nested FOR)",
    bullets: ["Ask how many stars to print; use an inner loop to print that many stars. Stop when user enters 0."],
    example: "Input 3 → prints *** ; Input 0 → stop",
    lines: [
      "REPEAT",
      "OUTPUT \"How many stars (0 to stop)\"",
      "INPUT n",
      "FOR i = 1 TO n DO",
      "OUTPUT \"*\"",
      "NEXT i",
      "UNTIL n = 0"
    ]
  },
  {
    title: "Print even numbers 1..N (REPEAT + inner loop)",
    bullets: [
      // changed to avoid explicit code wording
      "Repeatedly ask the user for a number N.",
      "Loop through the integers from 1 to N and output only those that are even.",
      "A sentinel value of 0 ends the whole process."
    ],
    example: "Input 5 → outputs 2 and 4 ; Input 0 → stop",
    lines: [
      "REPEAT",
      "OUTPUT \"Enter N (0 to stop)\"",
      "INPUT N",
      "FOR i = 1 TO N DO",
      "IF i MOD 2 = 0 THEN",
      "OUTPUT i",
      "ENDIF",
      "NEXT i",
      "UNTIL N = 0"
    ]
  }
];

// DOM refs
const codeBox = document.getElementById('codeBox');
const descTitle = document.getElementById('descTitle');
const descBullets = document.getElementById('descBullets');
const exampleBox = document.getElementById('exampleBox');
const puzzleSelect = document.getElementById('puzzleSelect');
const submitBtn = document.getElementById('submitBtn');
const revealHintBtn = document.getElementById('revealHintBtn');
const resetBtn = document.getElementById('resetBtn');
const nextBtn = document.getElementById('nextBtn');
const messageEl = document.getElementById('message');

let current = 0;
let pickedBlock = null;
const usedHintsCount = {}; // in-memory per puzzle

// shuffle helper
function shuffleArray(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function populatePuzzleSelect(){
  puzzleSelect.innerHTML = '';
  puzzles.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i+1}. ${p.title}`;
    puzzleSelect.appendChild(opt);
  });
  puzzleSelect.value = 0;
}

// render description (and Expected Output heading)
function renderDescription(idx){
  const p = puzzles[idx];
  descTitle.textContent = p.title;
  descBullets.innerHTML = '';
  p.bullets.forEach(b=>{
    const li = document.createElement('li');
    li.textContent = b;
    descBullets.appendChild(li);
  });
  if(p.example && p.example.trim() !== ''){
    exampleBox.style.display = 'block';
    // create heading + pre (safe)
    exampleBox.innerHTML = '';
    const head = document.createElement('div');
    head.style.fontWeight = '700';
    head.textContent = 'Expected Output';
    const pre = document.createElement('pre');
    pre.style.marginTop = '8px';
    pre.style.whiteSpace = 'pre-wrap';
    pre.textContent = p.example;
    exampleBox.appendChild(head);
    exampleBox.appendChild(pre);
  } else {
    exampleBox.style.display = 'none';
    exampleBox.innerHTML = '';
  }
  updateRevealHintBtn();
}

// build code box with scrambled lines; drag inserts at drop position (pushes down)
function buildCodeBox(idx){
  codeBox.innerHTML = '';
  const p = puzzles[idx];
  const items = p.lines.map((line, i) => ({line, idx:i}));
  const shuffled = items.slice();
  shuffleArray(shuffled);
  shuffled.forEach(item => {
    const el = document.createElement('div');
    el.className = 'block';
    el.draggable = true;
    el.tabIndex = 0;
    el.dataset.origIndex = String(item.idx); // correct position index
    el.textContent = item.line;

    // dragstart
    el.addEventListener('dragstart', e => {
      el.classList.add('dragging');
      // store id of dragged element (use a unique id: use current time + random if needed)
      // we'll store a reference by using a data key (origIndex + a random stamp) to avoid collisions
      // but origIndex is unique per puzzle lines so it's okay here.
      e.dataTransfer.setData('text/plain', el.dataset.origIndex);
      e.dataTransfer.effectAllowed = 'move';
    });

    el.addEventListener('dragend', ()=> el.classList.remove('dragging'));

    // allow dropping onto a block to insert dragged element at that spot
    el.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });

    el.addEventListener('drop', e => {
      e.preventDefault();
      const draggedOrig = e.dataTransfer.getData('text/plain');
      // find the dragged element by dataset.origIndex among current children
      const children = Array.from(codeBox.children);
      const draggedEl = children.find(c => c.dataset.origIndex === String(draggedOrig) && c !== el);
      if(!draggedEl) return;
      // When dropping, insert the dragged element *before* the target element
      // so the dragged element becomes the position of the target, pushing the target and subsequent lines down.
      // To achieve intuitive behaviour, if the dragged element came from above the drop target we will insert after the target
      // (so it appears to move 'down' onto the target). Otherwise insert before.
      const currentChildren = Array.from(codeBox.children);
      const a = currentChildren.indexOf(draggedEl);
      const b = currentChildren.indexOf(el);
      if(a < 0 || b < 0) return;

      if(a < b){
        // dragged from above -> insert after target so it lands below the target
        codeBox.insertBefore(draggedEl, el.nextSibling);
      } else {
        // dragged from below -> insert before target
        codeBox.insertBefore(draggedEl, el);
      }

      // quick visual nudge
      el.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}], {duration:140});
    });

    // click-to-swap support (click one block, then another to move the picked block to that place)
    el.addEventListener('click', onBlockClick);

    codeBox.appendChild(el);
  });

  // clear message and styling
  messageEl.textContent = '';
  Array.from(codeBox.children).forEach(c => c.classList.remove('correct','incorrect'));
  if(pickedBlock){ pickedBlock.style.outline=''; pickedBlock=null; }
  updateRevealHintBtn();
}

// click-to-swap handler: click one block (picked), click another to move the picked block to that position
function onBlockClick(e){
  const el = e.currentTarget;
  if(!pickedBlock){
    pickedBlock = el;
    el.style.outline = '3px solid rgba(5,104,214,0.18)';
    return;
  }
  if(pickedBlock === el){
    pickedBlock.style.outline = '';
    pickedBlock = null;
    return;
  }
  const children = Array.from(codeBox.children);
  const aIndex = children.indexOf(pickedBlock);
  const bIndex = children.indexOf(el);
  if(aIndex < 0 || bIndex < 0){
    pickedBlock.style.outline = ''; pickedBlock = null; return;
  }
  // Move pickedBlock to just before the clicked block (so it pushes it down)
  if(aIndex < bIndex){
    // if picked is above target, insert after target to make the movement feel like replacement
    codeBox.insertBefore(pickedBlock, el.nextSibling);
  } else {
    codeBox.insertBefore(pickedBlock, el);
  }
  pickedBlock.style.outline = '';
  pickedBlock = null;
  el.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}], {duration:120});
}

// check order (mark correct/incorrect). A block is correct if its original index equals its current index.
function checkOrder(){
  const p = puzzles[current];
  const children = Array.from(codeBox.children);
  let allCorrect = true;
  children.forEach((c, i) => {
    const correctIdx = Number(c.dataset.origIndex);
    if(correctIdx === i){
      c.classList.remove('incorrect'); c.classList.add('correct');
    } else {
      c.classList.remove('correct'); c.classList.add('incorrect');
      allCorrect = false;
    }
  });
  if(allCorrect){
    messageEl.textContent = 'All correct — great job!';
    messageEl.style.color = '#0b7';
  } else {
    messageEl.textContent = 'Some lines are in the wrong order. Incorrect blocks are highlighted.';
    messageEl.style.color = '#b33';
  }
}

// Reset = reshuffle current puzzle (keep hint counts)
function resetPuzzle(){
  buildCodeBox(current);
  messageEl.textContent = '';
}

// Next puzzle
function nextPuzzle(){
  current = (current + 1) % puzzles.length;
  puzzleSelect.value = current;
  loadPuzzle(current);
}

// Reveal hint: place one random incorrect block into its correct position
function revealHint(){
  const used = usedHintsCount[current] || 0;
  if(used >= MAX_HINTS_PER_PUZZLE){
    messageEl.textContent = `No hints left for this puzzle (max ${MAX_HINTS_PER_PUZZLE}).`;
    messageEl.style.color = '#a00';
    updateRevealHintBtn();
    return;
  }
  const children = Array.from(codeBox.children);
  const eligible = [];
  children.forEach((c, idx) => {
    const orig = Number(c.dataset.origIndex);
    if(orig !== idx) eligible.push({el:c, orig});
  });
  if(eligible.length === 0){
    messageEl.textContent = 'All lines are already correct.';
    messageEl.style.color = '#444';
    return;
  }
  const choice = eligible[Math.floor(Math.random()*eligible.length)];
  const block = choice.el;
  const targetPos = choice.orig;

  // remove block from DOM and insert at the correct position
  const remaining = Array.from(codeBox.children).filter(n => n !== block);
  if(targetPos >= remaining.length){
    codeBox.appendChild(block);
  } else {
    codeBox.insertBefore(block, remaining[targetPos]);
  }

  block.classList.remove('incorrect'); block.classList.add('correct');
  usedHintsCount[current] = used + 1;
  messageEl.textContent = `Hint used: one line placed correctly (${usedHintsCount[current]} of ${MAX_HINTS_PER_PUZZLE}).`;
  messageEl.style.color = '#0b5';
  updateRevealHintBtn();
}

// update hint button label and disabled state
function updateRevealHintBtn(){
  const used = usedHintsCount[current] || 0;
  const left = Math.max(0, MAX_HINTS_PER_PUZZLE - used);
  if(left <= 0){
    revealHintBtn.disabled = true;
    revealHintBtn.textContent = `Reveal hint (used up)`;
    revealHintBtn.style.opacity = '0.6';
  } else {
    revealHintBtn.disabled = false;
    revealHintBtn.textContent = `Reveal hint (${left} left)`;
    revealHintBtn.style.opacity = '1';
  }
}

// load puzzle by index
function loadPuzzle(idx){
  current = idx;
  puzzleSelect.value = idx;
  renderDescription(idx);
  buildCodeBox(idx);
  messageEl.textContent = '';
  if(pickedBlock){ pickedBlock.style.outline=''; pickedBlock=null; }
}

// init
function init(){
  populatePuzzleSelect();
  renderDescription(0);
  buildCodeBox(0);
  // wire events
  submitBtn.addEventListener('click', checkOrder);
  revealHintBtn.addEventListener('click', revealHint);
  resetBtn.addEventListener('click', resetPuzzle);
  nextBtn.addEventListener('click', nextPuzzle);
  puzzleSelect.addEventListener('change', e => loadPuzzle(Number(e.target.value)));
  // accessibility: pressing Enter on the code container focuses the first block
  codeBox.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      const first = codeBox.querySelector('.block');
      if(first) first.focus();
    }
  });
  updateRevealHintBtn();
}

init();

</script>
</body>
</html>
