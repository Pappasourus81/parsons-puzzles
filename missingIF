<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fill in the missing code â€” Conditionals</title>
<style>
Â  :root{
Â  Â  --bg:#f6f8fb;
Â  Â  --card:#ffffff;
Â  Â  --accent:#0b61d6;
Â  Â  --muted:#6b7280;
Â  Â  --success:#16a34a;
Â  Â  --danger:#ef4444;
Â  Â  --focus:#ffb703;
Â  Â  --bank-bg:#eef6ff;
Â  Â  --gap:12px;
Â  Â  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
Â  }
Â  html,body{height:100%;}
Â  body{
Â  Â  margin:16px;
Â  Â  background:linear-gradient(180deg,var(--bg),#eef3fb 60%);
Â  Â  color:#111827;
Â  Â  -webkit-font-smoothing:antialiased;
Â  Â  -moz-osx-font-smoothing:grayscale;
Â  }
Â  .container{
Â  Â  max-width:980px;
Â  Â  margin:0 auto;
Â  Â  padding:20px;
Â  }
Â  header{
Â  Â  display:flex;
Â  Â  align-items:center;
Â  Â  gap:16px;
Â  Â  margin-bottom:18px;
Â  }
Â  h1{
Â  Â  font-size:20px;
Â  Â  margin:0;
Â  }
Â  .meta{
Â  Â  color:var(--muted);
Â  Â  font-size:13px;
Â  }

Â  .puzzle-card{
Â  Â  background:var(--card);
Â  Â  border-radius:10px;
Â  Â  box-shadow:0 6px 20px rgba(15,23,42,0.06);
Â  Â  padding:18px;
Â  Â  margin-bottom:18px;
Â  Â  border:1px solid rgba(15,23,42,0.04);
Â  }

Â  .desc{
Â  Â  background:linear-gradient(90deg,#fff,#fbfdff);
Â  Â  padding:12px;
Â  Â  border-radius:8px;
Â  Â  border:1px dashed rgba(11,97,214,0.08);
Â  Â  margin-bottom:12px;
Â  }
Â  .desc p{margin:6px 0;color:#0f172a;font-size:14px}
Â  .example{color:var(--muted);font-size:13px;margin-top:6px}

Â  /* pseudocode area */
Â  .code-wrap{
Â  Â  background:#0f172a;
Â  Â  color:#e6eef8;
Â  Â  border-radius:8px;
Â  Â  padding:12px;
Â  Â  font-family: "Courier New", Courier, monospace;
Â  Â  font-size:14px;
Â  Â  overflow:auto;
Â  Â  line-height:1.6;
Â  }
Â  .code-line{
Â  Â  white-space:pre;
Â  }
Â  .blank {
Â  Â  display:inline-block;
Â  Â  min-width:48px;
Â  Â  padding:2px 6px;
Â  Â  margin:0 2px;
Â  Â  border-radius:6px;
Â  Â  background:rgba(255,255,255,0.07);
Â  Â  color:#fff;
Â  Â  border:2px dashed rgba(255,255,255,0.08);
Â  Â  outline: none;
Â  Â  cursor:pointer;
Â  Â  vertical-align:baseline;
Â  }
Â  .blank:focus { box-shadow:0 0 0 3px rgba(255,183,3,0.14); border-color:var(--focus);}
Â  .blank.empty{ color:#cbd5e1; font-style:italic;}
Â  .blank.correct { background:rgba(22,163,74,0.18); border-color:rgba(22,163,74,0.5); color:var(--success); }
Â  .blank.incorrect { background:rgba(239,68,68,0.12); border-color:rgba(239,68,68,0.3); color:var(--danger); }

Â  /* bank */
Â  .bank{
Â  Â  margin-top:12px;
Â  Â  display:flex;
Â  Â  gap:8px;
Â  Â  flex-wrap:wrap;
Â  Â  background:var(--bank-bg);
Â  Â  padding:10px;
Â  Â  border-radius:8px;
Â  Â  border:1px solid rgba(11,97,214,0.06);
Â  }
Â  .token{
Â  Â  user-select:none;
Â  Â  padding:8px 10px;
Â  Â  border-radius:8px;
Â  Â  background:#fff;
Â  Â  border:1px solid rgba(2,6,23,0.06);
Â  Â  box-shadow:0 2px 6px rgba(2,6,23,0.04);
Â  Â  font-weight:600;
Â  Â  font-size:13px;
Â  Â  cursor:grab;
Â  }
Â  .token:active{ cursor:grabbing }
Â  .token[aria-pressed="true"]{ outline:3px solid rgba(11,97,214,0.14); box-shadow:0 6px 18px rgba(11,97,214,0.08); }
Â  .token:focus { box-shadow:0 0 0 3px rgba(11,97,214,0.10); outline:none; }

Â  /* controls */
Â  .controls{
Â  Â  display:flex;
Â  Â  gap:10px;
Â  Â  margin-top:12px;
Â  Â  align-items:center;
Â  Â  flex-wrap:wrap;
Â  }
Â  button{
Â  Â  padding:9px 14px;
Â  Â  border-radius:8px;
Â  Â  border:0;
Â  Â  font-weight:600;
Â  Â  background:var(--accent);
Â  Â  color:white;
Â  Â  cursor:pointer;
Â  Â  box-shadow:0 6px 18px rgba(11,97,214,0.10);
Â  }
Â  button.secondary{
Â  Â  background:#fff; color:var(--accent); border:1px solid rgba(11,97,214,0.10);
Â  Â  box-shadow:none;
Â  }
Â  button.ghost{
Â  Â  background:transparent; color:var(--muted); border:1px dashed rgba(2,6,23,0.06);
Â  }
Â  .msg{ margin-left:8px; color:var(--muted); font-weight:600; }

Â  select.puzzle-select{ padding:8px; border-radius:8px; border:1px solid rgba(2,6,23,0.06); background:#fff; color:#0f172a; font-weight:600; }

Â  /* small screens */
Â  @media (max-width:640px){
Â  Â  .container{ padding:12px; }
Â  Â  header{ gap:8px; }
Â  Â  .code-wrap{ font-size:13px; }
Â  Â  .token{ font-size:12px; padding:7px 9px; }
Â  Â  button{ padding:8px 10px; font-size:14px; }
Â  }

Â  /* focus outlines for keyboard users */
Â  :focus { outline: none; }
Â  .a11y-focus { box-shadow:0 0 0 3px rgba(255,183,3,0.14); border-radius:6px; }

Â  /* subtle helper text */
Â  .help{ color:var(--muted); font-size:13px; margin-top:10px;}
</style>
</head>
<body>
<div class="container" id="app">
Â  <header>
Â  Â  <div>
Â  Â  Â  <h1>Fill in the missing code â€” Conditionals</h1>
Â  Â  Â  <div class="meta">Drag or click tokens into blanks. Press Enter to place when using keyboard.</div>
Â  Â  </div>
Â  </header>

Â  <main>
Â  Â  <section class="puzzle-card" id="puzzleCard" aria-live="polite">
Â  Â  Â  <div class="desc" id="descBox" role="region" aria-label="Puzzle description"></div>

Â  Â  Â  <div class="code-wrap" id="codeWrap" role="region" aria-label="Pseudocode area">
Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  <div class="bank" id="bank" aria-label="Word bank" role="listbox" tabindex="0"></div>

Â  Â  Â  <div class="controls" style="justify-content:flex-start;">
Â  Â  Â  Â  <button id="submitBtn">Submit</button>
Â  Â  Â  Â  <button id="revealHintBtn" class="ghost">Reveal hint (3 left)</button>
Â  Â  Â  Â  <button class="secondary" id="resetBtn">Reset (reshuffle)</button>
Â  Â  Â  Â  <button class="ghost" id="nextBtn">Next Puzzle â†’</button>

Â  Â  Â  Â  <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
Â  Â  Â  Â  Â  <label style="color:var(--muted); font-weight:600;">Puzzle</label>
Â  Â  Â  Â  Â  <select id="puzzleSelect" class="puzzle-select" aria-label="Select puzzle"></select>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="msg" id="feedback" aria-live="assertive"></div>
Â  Â  Â  </div>

Â  Â  Â  <div class="help">Keyboard: <strong>Tab</strong> to move, <strong>Enter</strong> to pick/place, <strong>Escape</strong> to drop.</div>
Â  Â  </section>

Â  Â  
Â  </main>
</div>

<script>
/*
Â  Conditionals fill-in-the-blanks
Â  - Reusable tokens
Â  - Drag & drop + keyboard
Â  - Submit / Reset / Next / Puzzle selector
Â  - Reveal hint (fills a random incorrect blank), up to 3 per puzzle (in-session)
Â  - Puzzles array comes from your provided file (unmodified)
*/

(function(){
Â  // Utility: shuffle array copy
Â  function shuffle(a){
Â  Â  const arr = a.slice();
Â  Â  for(let i=arr.length-1;i>0;i--){
Â  Â  Â  const j=Math.floor(Math.random()*(i+1));
Â  Â  Â  [arr[i],arr[j]]=[arr[j],arr[i]];
Â  Â  }
Â  Â  return arr;
Â  }

Â  // --- puzzles (taken from your provided content) ---
Â  const puzzles = [
Â  Â  {
Â  Â  Â  title: "Basic IF â€” positive check",
Â  Â  Â  description: "Read an integer and output whether it is positive. Input: one number. Output: a short message when the number is positive.",
Â  Â  Â  example: "If the input is 5 the program should output: The number is positive",
Â  Â  Â  lines: [
"INPUT number",
"IF number ___1___ 0 ___2___",
"    OUTPUT \"The number is positive\"",
"ENDIF"
Â  Â  Â  ],
Â  Â  Â  bank: ["THEN", ">", "<", "ELSE"],
Â  Â  Â  solution: {1: ">", 2: "THEN"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "IF-ELSE â€” even or odd (MOD)",
Â  Â  Â  description: "Read an integer and print whether it is even or odd. Use the MOD operator to test divisibility.",
Â  Â  Â  example: "Input 4 -> outputs: Even",
Â  Â  Â  lines: [
"INPUT n",
"IF n ___1___ 2 ___2___ 0 ___3___",
"    OUTPUT \"Even\"",
"ELSE",
"    OUTPUT \"Odd\"",
"ENDIF"
Â  Â  Â  ],
Â  Â  Â  bank: ["MOD","THEN","=","ELSE","%","<>"],
Â  Â  Â  solution: {1: "MOD", 2: "=", 3: "THEN"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "Nested IF-ELSE (single nested) â€” positive & large",
Â  Â  Â  description: "Read a number. If it is positive, check whether it is larger than 100 and respond. This puzzle has one nested IF-ELSE.",
Â  Â  Â  example: "Input 150 -> outputs: Large and positive",
Â  Â  Â  lines: [
"INPUT x",
"IF x ___1___ 0 ___2___",
"    IF x ___3___ 100 ___4___",
"        OUTPUT \"Large and positive\"",
"    ELSE",
"        OUTPUT \"Positive but not large\"",
"    ENDIF",
"ELSE",
"    OUTPUT \"Not positive\"",
"ENDIF"
Â  Â  Â  ],
Â  Â  Â  bank: [">","THEN","<","ELSE","="],
Â  Â  Â  solution: {1: ">", 2: "THEN", 3: ">", 4: "THEN"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "IF with ELSE â€” zero or not",
Â  Â  Â  description: "Read a number and report if it is zero or not zero.",
Â  Â  Â  example: "Input 0 -> outputs: Zero",
Â  Â  Â  lines: [
"INPUT number",
"___3___ number ___1___ 0 ___2___",
"    OUTPUT \"Zero\"",
"___4___",
"    OUTPUT \"Not zero\"",
"___5___"
Â  Â  Â  ],
Â  Â  Â  bank: ["THEN","=","MOD","ELSE","<>", "IF", "ENDIF"],
Â  Â  Â  solution: {1: "=", 2: "THEN", 3: "IF", 4: "ELSE", 5: "ENDIF"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "Basic CASE â€” options",
Â  Â  Â  description: "Read a code and select one of three options.",
Â  Â  Â  example: "Input 2 -> outputs: Option Two",
Â  Â  Â  lines: [
"INPUT code",
"___1___ code ___2___",
"    1: OUTPUT \"Option One\"",
"    2: OUTPUT \"Option Two\"",
"    3: OUTPUT \"Option Three\"",
"    ___3___",
"        OUTPUT \"Unknown\"",
"___4___"
Â  Â  Â  ],
Â  Â  Â  bank: ["CASE","OF","OTHERWISE","ENDCASE","WHEN","SWITCH", "DEFAULT"],
Â  Â  Â  solution: {1: "CASE", 2: "OF", 3: "OTHERWISE", 4: "ENDCASE"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "CASE inside IF â€” admin message",
Â  Â  Â  description: "If admin is 1 show a CASE with specific admin welcome messages.",
Â  Â  Â  example: "Input admin=1 and code=1 -> outputs: Welcome, superadmin",
Â  Â  Â  lines: [
"INPUT admin",
"INPUT code",
"IF admin ___1___ 1 ___2___",
"    CASE code ___3___",
"        1: OUTPUT \"Welcome, superadmin\"",
"        2: OUTPUT \"Welcome, admin\"",
"        ___4___",
"            OUTPUT \"Welcome\"",
"    ___5___",
"ENDIF"
Â  Â  Â  ],
Â  Â  Â  bank: ["=","THEN","OF","OTHERWISE","ENDCASE","<>","ELSE", "DEFAULT"],
Â  Â  Â  solution: {1: "=", 2: "THEN", 3: "OF", 4: "OTHERWISE", 5: "ENDCASE"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "IF with CASEs in both branches",
Â  Â  Â  description: "If userType = 1 run a CASE for admin options; otherwise run a CASE for guest options.",
Â  Â  Â  example: "userType=2 and choice=1 -> outputs: Guest: View",
Â  Â  Â  lines: [
"INPUT userType",
"INPUT choice",
"IF userType ___1___ 1 ___2___",
"    ___3___ choice ___4___",
"        1: OUTPUT \"Admin: Edit\"",
"        2: OUTPUT \"Admin: Delete\"",
"        ___5___",
"            OUTPUT \"Admin: Unknown\"",
"    ___6___",
"___7___",
"    ___8___ choice ___9___",
"        1: OUTPUT \"Guest: View\"",
"        2: OUTPUT \"Guest: Browse\"",
"        ___10___",
"            OUTPUT \"Guest: Unknown\"",
"    ___11___",
"ENDIF"
Â  Â  Â  ],
Â  Â  Â  bank: ["=","THEN","OF","ENDCASE","ELSE","CASE","OTHERWISE", "DEFAULT", "END"],
Â  Â  Â  solution: {
        1: "=", 2: "THEN", 3: "CASE", 4: "OF", 5: "OTHERWISE", 6: "ENDCASE",
        7: "ELSE", 8: "CASE", 9: "OF", 10: "OTHERWISE", 11: "ENDCASE"
    }
Â  Â  },
Â  Â  {
Â  Â  Â  title: "Two separate IF-ELSE statements (independent)",
Â  Â  Â  description: "Read temperature and windSpeed. Check two independent conditions and output messages for each. Fill relational operators and THENs.",
Â  Â  Â  example: "temp=30 -> 'Hot'; windSpeed=25 -> 'Windy'",
Â  Â  Â  lines: [
"INPUT temp",
"INPUT windSpeed",
"___5___ temp ___1___ 25 ___2___",
"    ___6___ \"Hot\"",
"___7___",
"    ___8___ \"Not hot\"",
"___9___",
"IF windSpeed ___3___ 20 ___4___",
"    OUTPUT \"Windy\"",
"ELSE",
"    OUTPUT \"Calm\"",
"___10___"
Â  Â  Â  ],
Â  Â  Â  bank: [">","THEN","MOD","<","=","ELSE","<>", "IF", "OUTPUT", "ENDIF"],
Â  Â  Â  solution: {1: ">", 2: "THEN", 3: ">", 4: "THEN", 5: "IF", 6: "OUTPUT", 7: "ELSE", 8: "OUTPUT", 9: "ENDIF", 10: "ENDIF"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "IF using SUBSTRING â€” prefix check",
Â  Â  Â  description: "Read a word. If its first three letters are 'pre' output a message.",
Â  Â  Â  example: "Input 'prefix' -> outputs: Starts with pre",
Â  Â  Â  lines: [
"___5___ word",
"___6___ ___1___(word,___7___,___8___) ___2___ ___3___ ___4___",
"    ___9___ \"Starts with pre\"",
"___10___",
"    ___11___ \"Different prefix\"",
"___12___"
Â  Â  Â  ],
Â  Â  Â  bank: ["SUBSTRING","=","\"pre\"","THEN","ELSE","LEFT","MID", "INPUT", "IF", "1", "3", "OUTPUT", "ENDIF"],
Â  Â  Â  solution: {1: "SUBSTRING", 2: "=", 3: "\"pre\"", 4: "THEN", 5: "INPUT", 6: "IF", 7: "1", 8: "3", 9: "OUTPUT", 10: "ELSE", 11: "OUTPUT", 12: "ENDIF"}
Â  Â  },
Â  Â  {
Â  Â  Â  title: "Final: CASE + SUBSTRING + ROUND (hard)",
Â  Â  Â  description: "Read a name and a score. If the name's prefix (first 3 letters) matches \"Ann\", greet them. Otherwise, round the score and use a CASE to output a message based on the rounded value.",
Â  Â  Â  example: "name='Ann'; score=4.6 -> rounded 5 -> outputs: Excellent",
Â  Â  Â  lines: [
"INPUT name",
"INPUT score",
"",
"___1___ ___2___(name, 1, 3) = ___3___ ___4___",
"    OUTPUT \"Hello Ann\"",
"___5___",
"    scoreRounded â† ___6___(score)",
"    ___7___ ___8___ ___9___",
"        5: OUTPUT \"Excellent\"",
"        4: OUTPUT \"Good\"",
"        ___10___",
"            OUTPUT \"Keep trying\"",
"    ___11___",
"___12___"
Â  Â  Â  ],
Â  Â  Â  bank: [
Â  Â  Â  Â  "IF", "SUBSTRING", "\"Ann\"", "THEN", "ELSE", "ROUND", "CASE", "scoreRounded", "OF", "OTHERWISE", "ENDCASE", "ENDIF",
        "INPUT", "OUTPUT", "DEFAULT", "PRINT", "RANDOM", "SUBSTR", "LET", "<-", "="
Â  Â  Â  ],
Â  Â  Â  solution: {
Â  Â  Â  Â  1: "IF",
Â  Â  Â  Â  2: "SUBSTRING",
Â  Â  Â  Â  3: "\"Ann\"",
Â  Â  Â  Â  4: "THEN",
Â  Â  Â  Â  5: "ELSE",
Â  Â  Â  Â  6: "ROUND",
Â  Â  Â  Â  7: "CASE",
Â  Â  Â  Â  8: "scoreRounded",
Â  Â  Â  Â  9: "OF",
Â  Â  Â  Â  10: "OTHERWISE",
Â  Â  Â  Â  11: "ENDCASE",
Â  Â  Â  Â  12: "ENDIF"
Â  Â  Â  }
Â  Â  }
Â  ];
Â  // --- end-of-puzzles ---

Â  // App state
Â  let puzzleIndex = 0;
Â  let currentPuzzle = null;
Â  let bankTokens = [];
Â  let blankState = {}; // blankNum -> token string or null
Â  let selectedTokenIndex = null; // index into bankTokens for keyboard selection
Â  const usedHintsCount = {}; // puzzleIndex -> used hints

Â  // Elements
Â  const descBox = document.getElementById('descBox');
Â  const codeWrap = document.getElementById('codeWrap');
Â  const bankEl = document.getElementById('bank');
Â  const feedbackEl = document.getElementById('feedback');
Â  const submitBtn = document.getElementById('submitBtn');
Â  const resetBtn = document.getElementById('resetBtn');
Â  const nextBtn = document.getElementById('nextBtn');
Â  const revealHintBtn = document.getElementById('revealHintBtn');
Â  const puzzleSelect = document.getElementById('puzzleSelect');

Â  // Init
Â  function init(){
Â  Â  populatePuzzleSelect();
Â  Â  loadPuzzle(0);
Â  Â  // events
Â  Â  submitBtn.addEventListener('click', onSubmit);
Â  Â  resetBtn.addEventListener('click', onReset);
Â  Â  nextBtn.addEventListener('click', onNext);
Â  Â  revealHintBtn.addEventListener('click', onRevealHint);
Â  Â  puzzleSelect.addEventListener('change', (e)=> loadPuzzle(Number(e.target.value)));
Â  Â  document.addEventListener('keydown', (e)=> { if(e.key === 'Escape'){ clearSelection(); } });
Â  }

Â  function populatePuzzleSelect(){
Â  Â  puzzleSelect.innerHTML = '';
Â  Â  puzzles.forEach((p,i)=>{
Â  Â  Â  const opt = document.createElement('option');
Â  Â  Â  opt.value = i;
Â  Â  Â  opt.textContent = `${i+1}. ${p.title}`;
Â  Â  Â  puzzleSelect.appendChild(opt);
Â  Â  });
Â  }

Â  function loadPuzzle(index){
Â  Â  puzzleIndex = index % puzzles.length;
Â  Â  currentPuzzle = JSON.parse(JSON.stringify(puzzles[puzzleIndex])); // copy to avoid in-place edits
Â  Â  bankTokens = shuffle(currentPuzzle.bank.slice());
Â  Â  // set blanks
Â  Â  const blanks = extractBlanks(currentPuzzle.lines);
Â  Â  blankState = {};
Â  Â  blanks.forEach(n => blankState[n] = null);
Â  Â  selectedTokenIndex = null;
Â  Â  feedbackEl.textContent = '';
Â  Â  // ensure usedHintsCount key exists
Â  Â  if(typeof usedHintsCount[puzzleIndex] === 'undefined') usedHintsCount[puzzleIndex] = 0;
Â  Â  // render
Â  Â  renderDescription();
Â  Â  renderCode();
Â  Â  renderBank();
Â  Â  updateRevealHintBtn();
Â  Â  puzzleSelect.value = puzzleIndex;
Â  }

Â  function extractBlanks(lines){
Â  Â  const re = /___(\d+)___/g;
Â  Â  const set = new Set();
Â  Â  lines.forEach(line=>{
Â  Â  Â  let m;
Â  Â  Â  while((m=re.exec(line))!==null) set.add(Number(m[1]));
Â  Â  });
Â  Â  return Array.from(set).sort((a,b)=>a-b);
Â  }

Â  function renderDescription(){
Â  Â  descBox.innerHTML = '';
Â  Â  const title = document.createElement('strong');
Â  Â  title.textContent = currentPuzzle.title;
Â  Â  const p = document.createElement('p');
Â  Â  p.textContent = currentPuzzle.description || '';
Â  Â  descBox.appendChild(title);
Â  Â  descBox.appendChild(p);
Â  Â  if(currentPuzzle.example){
Â  Â  Â  const ex = document.createElement('div');
Â  Â  Â  ex.className = 'example';
Â  Â  Â  ex.textContent = 'Example: ' + currentPuzzle.example;
Â  Â  Â  descBox.appendChild(ex);
Â  Â  }
Â  }

Â  function renderCode(){
Â  Â  codeWrap.innerHTML = '';
Â  Â  const re = /___(\d+)___/g;
Â  Â  currentPuzzle.lines.forEach(line=>{
Â  Â  Â  const lineDiv = document.createElement('div');
Â  _ Â  lineDiv.className = 'code-line';
Â  Â  Â  let last = 0;
Â  Â  Â  let m;
Â  Â  Â  const frag = document.createDocumentFragment();
Â  Â  Â  while((m = re.exec(line)) !== null){
Â  Â  Â  Â  const before = line.slice(last, m.index);
Â  Â  Â  Â  if(before) frag.appendChild(document.createTextNode(before));
Â  Â  Â  Â  const bnum = Number(m[1]);
Â  Â  Â  Â  const btn = document.createElement('button');
Â  Â  Â  Â  btn.type = 'button';
Â  Â  Â  Â  btn.className = 'blank empty';
Â  Â  Â  Â  btn.setAttribute('data-blank', String(bnum));
Â  Â  Â  Â  btn.setAttribute('tabindex','0');
Â  Â  Â  Â  btn.setAttribute('aria-label', `Blank ${bnum}. Press Enter to place token.`);
Â  Â  Â  Â  btn.textContent = '___' + bnum + '___';
Â  Â  Â  Â  // click to place selected token / clear existing
Â  Â  Â  Â  btn.addEventListener('click', ()=> onBlankClick(bnum, btn));
Â  Â  Â  Â  btn.addEventListener('keydown', (e)=> {
Â  Â  Â  Â  Â  if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); onBlankClick(bnum, btn); }
Â  Â  Â  Â  Â  else if(e.key === 'Escape'){ clearSelection(); }
Â  Â  Â  Â  });
Â  Â  Â  Â  // allow drag-drop
Â  Â  Â  Â  btn.addEventListener('dragover', (ev)=> { ev.preventDefault(); ev.dataTransfer.dropEffect='move'; });
Â  Â  Â  Â  btn.addEventListener('drop', onBlankDrop);
Â  Â  Â  Â  frag.appendChild(btn);
Â  Â  Â  Â  last = re.lastIndex;
Â  Â  Â  }
Â  Â  Â  if(last < line.length) frag.appendChild(document.createTextNode(line.slice(last)));
Â  Â  Â  lineDiv.appendChild(frag);
Â  Â  Â  codeWrap.appendChild(lineDiv);
Â  Â  });
Â  Â  updateBlankDisplays();
Â  }

Â  function renderBank(){
Â  Â  bankEl.innerHTML = '';
Â  Â  bankEl.setAttribute('aria-label','Word bank. ' + bankTokens.length + ' tokens.');
Â  Â  bankTokens.forEach((tok, i) => {
Â  Â  Â  const t = document.createElement('div');
Â  Â  Â  t.className = 'token';
Â  Â  Â  t.setAttribute('role','option');
Â  Â  Â  t.setAttribute('tabindex','0');
Â  Â  Â  t.setAttribute('data-index', String(i));
Â  Â  Â  t.setAttribute('data-token', tok);
Â  Â  Â  t.textContent = tok;
Â  Â  Â  // drag start
Â  Â  Â  t.addEventListener('dragstart', (ev)=> {
Â  Â  Â  Â  ev.dataTransfer.setData('text/plain', String(i));
Â  Â  Â  Â  ev.dataTransfer.effectAllowed = 'move';
Â  Â  Â  });
Â  Â  Â  // click to select
Â  Â  Â  t.addEventListener('click', ()=> onTokenClick(i, t));
Â  Â  Â  t.addEventListener('keydown', (ev)=> {
Â  Â  Â  Â  if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); onTokenClick(i, t); }
Â  Â  Â  Â  else if(ev.key === 'Escape'){ clearSelection(); }
Â  Â  Â  });
Â  Â  Â  bankEl.appendChild(t);
Â  Â  });

Â  Â  // bank accepts drops from blanks to clear them (but tokens are reusable so we just clear)
Â  Â  bankEl.addEventListener('dragover', (ev)=> { ev.preventDefault(); ev.dataTransfer.dropEffect='move'; });
Â  Â  bankEl.addEventListener('drop', (ev)=> {
Â  Â  Â  ev.preventDefault();
Â  Â  Â  const data = ev.dataTransfer.getData('text/plain') || '';
Â  Â  Â  if(data.startsWith('blank:')){
Â  Â  Â  Â  const bnum = Number(data.split(':')[1]);
Â  Â  Â  Â  if(!isNaN(bnum) && blankState[bnum]){
Â  Â  Â  Â  Â  // clear blank (do not add token back since tokens are reusable)
Â  Â  Â  Â  Â  blankState[bnum] = null;
Â  Â  Â  Â  Â  updateBlankDisplays();
Â  Â  Â  Â  Â  feedbackEl.textContent = '';
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  }

Â  function updateBlankDisplays(){
Â  Â  const blanks = codeWrap.querySelectorAll('.blank');
Â  Â  blanks.forEach(btn => {
Â  Â  Â  const bnum = Number(btn.getAttribute('data-blank'));
Â  Â  Â  const val = blankState[bnum];
Â  Â  Â  btn.classList.remove('empty','correct','incorrect');
Â  Â  Â  if(!val){
Â  Â  Â  Â  btn.classList.add('empty');
Â  Â  Â  Â  btn.textContent = '___' + bnum + '___';
Â  Â  Â  Â  btn.setAttribute('aria-label','Blank ' + bnum + '. empty.');
Â  Â  Â  } else {
Â  Â  Â  Â  btn.textContent = val;
Â  Â  Â  Â  btn.setAttribute('aria-label','Blank ' + bnum + '. contains ' + val + '.');
Â  Â  Â  }
Â  Â  });
Â  Â  refreshBankVisual();
Â  }

Â  function refreshBankVisual(){
Â  Â  const tokens = bankEl.querySelectorAll('.token');
Â  Â  tokens.forEach(t => {
Â  Â  Â  const idx = Number(t.getAttribute('data-index'));
Â  Â  Â  if(selectedTokenIndex === idx){
Â  Â  Â  Â  t.setAttribute('aria-pressed','true');
Â  Â  Â  Â  t.classList.add('selected');
Â  Â  Â  } else {
Â  Â  Â  Â  t.setAttribute('aria-pressed','false');
Â  Â  Â  Â  t.classList.remove('selected');
Â  Â  Â  }
Â  Â  });
Â  }

Â  // token click
Â  function onTokenClick(index, el){
Â  Â  if(selectedTokenIndex === index){ clearSelection(); return; }
Â  Â  selectedTokenIndex = index;
Â  Â  refreshBankVisual();
Â  }

Â  function clearSelection(){
Â  Â  selectedTokenIndex = null;
Â  Â  refreshBankVisual();
Â  }

Â  // blank click (place or clear)
Â  function onBlankClick(bnum, el){
Â  Â  if(selectedTokenIndex !== null && typeof bankTokens[selectedTokenIndex] !== 'undefined'){
Â  Â  Â  // place the selected token into the blank (but keep it in the bank â€” reusable)
Â  Â  Â  blankState[bnum] = bankTokens[selectedTokenIndex];
Â  Â  Â  updateBlankDisplays();
Â  Â  Â  clearSelection();
Â  Â  Â  return;
Â  Â  }
Â  Â  // If blank already has token, clicking clears it (since tokens are reusable)
Â  Â  if(blankState[bnum]){
Â  Â  Â  blankState[bnum] = null;
Â  Â  Â  updateBlankDisplays();
Â  Â  Â  feedbackEl.textContent = '';
Â  Â  Â  return;
Â  Â  }
Â  Â  // else nothing selected and blank empty: no-op
Â  }

Â  // drop handler for blank (from bank drag)
Â  function onBlankDrop(ev){
Â  Â  ev.preventDefault();
Â  Â  const data = ev.dataTransfer.getData('text/plain');
Â  Â  let idx = null;
Â  _ Â  if(data && !data.startsWith('blank:')) idx = Number(data);
Â  Â  if(isNaN(idx)) return;
Â  Â  const bnum = Number(ev.currentTarget.getAttribute('data-blank'));
Â  Â  if(typeof bankTokens[idx] !== 'undefined'){
Â  Â  Â  blankState[bnum] = bankTokens[idx];
Â  Â  Â  updateBlankDisplays();
Â  Â  Â  clearSelection();
Â  Â  }
Â  }

Â  // dragstart from blank to clear it (data 'blank:N')
Â  // we attach dragstart directly when creating blanks, but implement here generically:
Â  // (we need to add dragstart on blanks)
Â  // Add dragstart to blanks dynamically:
Â  function attachBlankDragStarts(){
Â  Â  const blanks = codeWrap.querySelectorAll('.blank');
Â  Â  blanks.forEach(b => {
Â  Â  Â  if(!b._blankDragAssigned){
Â  Â  Â  Â  b.setAttribute('draggable','true');
Â  Â  Â  Â  b.addEventListener('dragstart', (ev)=> {
Â  Â  Â  Â  Â  const bnum = Number(b.getAttribute('data-blank'));
Â  Â  Â  Â  Â  if(blankState[bnum]){
Â  Â  Â  Â  Â  Â  ev.dataTransfer.setData('text/plain', 'blank:' + bnum);
Â  Â  Â  Â  Â  Â  // do not remove token from bank â€” tokens are reusable; clear blank on drop in bank
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  ev.preventDefault();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  b._blankDragAssigned = true;
Â  Â  Â  }
Â  Â  });
Â  }

Â  // Submit: check blanks against solution mapping
Â  function onSubmit(){
Â  Â  const solution = currentPuzzle.solution || {};
Â  Â  let allCorrect = true;
Â  Â  Object.keys(blankState).forEach(k => {
Â  Â  Â  const n = Number(k);
Â  Â  Â  const placed = blankState[n] || null;
Â  Â  Â  const expected = solution[n];
Â  Â  Â  const el = codeWrap.querySelector('.blank[data-blank="'+n+'"]');
Â  Â  Â  el.classList.remove('correct','incorrect');
Â  Â  Â  if(typeof expected === 'undefined'){
Â  Â  Â  Â  // no expected answer defined -> leave neutral
Â  Â  Â  } else {
Â  Â  Â  Â  if(placed === expected){
Â  Â  Â  Â  Â  el.classList.add('correct');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  el.classList.add('incorrect');
Â  Â  Â  Â  Â  allCorrect = false;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  Â  if(allCorrect){
Â  Â  Â  feedbackEl.textContent = 'All correct! Well done ğŸ‰';
Â  Â  } else {
Â  Â  Â  feedbackEl.textContent = 'Some blanks are incorrect â€” incorrect blanks are highlighted.';
Â  Â  }
Â  }

Â  // Reset: clear blanks, reshuffle bank (tokens reusable so we just shuffle)
Â  function onReset(){
Â  Â  Object.keys(blankState).forEach(k => blankState[k] = null);
Â  Â  bankTokens = shuffle(currentPuzzle.bank.slice());
Â  Â  renderBank();
Â  Â  updateBlankDisplays();
Â  Â  feedbackEl.textContent = 'Reset â€” bank reshuffled.';
Â  Â  selectedTokenIndex = null;
Â  Â  updateRevealHintBtn();
Â  }

Â  // Next puzzle
Â  function onNext(){
Â  Â  const nextIndex = (puzzleIndex + 1) % puzzles.length;
Â  Â  loadPuzzle(nextIndex);
Â  }

Â  // Reveal hint: fill one randomly chosen incorrect (or empty) blank with its correct token
Â  function onRevealHint(){
Â  Â  const used = usedHintsCount[puzzleIndex] || 0;
Â  Â  if(used >= 3){
Â  Â  Â  feedbackEl.textContent = 'No hints left for this puzzle.';
Â  Â  Â  return;
Â  Â  }
Â  Â  const solution = currentPuzzle.solution || {};
Â  Â  // find eligible blanks where expected exists and placed != expected
Â  Â  const eligible = [];
Â  Â  Object.keys(blankState).forEach(k => {
Â  Â  Â  const n = Number(k);
Â  Â  Â  const expected = solution[n];
Â  Â  Â  if(typeof expected === 'undefined') return;
s Â  Â  const placed = blankState[n] || null;
Â  Â  Â  if(placed !== expected) eligible.push(n);
Â  Â  });
Â  Â  if(eligible.length === 0){
Â  Â  Â  feedbackEl.textContent = 'All blanks are already correct or there are no defined answers to reveal.';
Â  Â  Â  return;
Â  Â  }
Â  Â  const pick = eligible[Math.floor(Math.random() * eligible.length)];
Â  Â  blankState[pick] = solution[pick];
Â  Â  usedHintsCount[puzzleIndex] = used + 1;
Â  Â  updateBlankDisplays();
Â  Â  feedbackEl.textContent = `Hint used: a blank has been filled (${usedHintsCount[puzzleIndex]} of 3).`;
Â  Â  updateRevealHintBtn();
Â  }

Â  function updateRevealHintBtn(){
Â  Â  const used = usedHintsCount[puzzleIndex] || 0;
Â  Â  const left = Math.max(0, 3 - used);
Â  Â  if(left <= 0){
Â  Â  Â  revealHintBtn.disabled = true;
Â  Â  Â  revealHintBtn.textContent = 'Reveal hint (used up)';
Â  Â  Â  revealHintBtn.style.opacity = 0.6;
Â  Â  } else {
Â  Â  Â  revealHintBtn.disabled = false;
Â  Â  Â  revealHintBtn.textContent = `Reveal hint (${left} left)`;
Â  _ Â  revealHintBtn.style.opacity = 1;
Â  Â  }
Â  }

Â  function clearSelection(){
Â  Â  selectedTokenIndex = null;
Â  Â  refreshBankVisual();
Â  }

Â  // helper to attach blank dragstarts after render
Â  function postRenderSetup(){
Â  Â  attachBlankDragStarts();
Â  }

Â  // wire up blank drop handling after each render
Â  const observer = new MutationObserver(()=> {
What is this for?
Â  Â  // ensure blanks accept dragstart events
Â  Â  postRenderSetup();
Â  });
Â  observer.observe(codeWrap, { childList:true, subtree:true });

Â  // load initial puzzle
Â  loadPuzzle(0);
Â  init();

Â  // expose helpers for debugging (optional)
Â  window._condPuzzle = {
Â  Â  puzzles,
Â  Â  goTo: (i)=> loadPuzzle(i % puzzles.length),
s Â  usedHintsCount,
Â  };

})();
</script>
</body>
</html>
