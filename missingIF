<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fill in the missing code â€” Conditionals</title>
<style>
  :root{
    --bg:#f6f8fb;
    --card:#ffffff;
    --accent:#0b61d6;
    --muted:#6b7280;
    --success:#16a34a;
    --danger:#ef4444;
    --focus:#ffb703;
    --bank-bg:#eef6ff;
    --gap:12px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;}
  body{
    margin:16px;
    background:linear-gradient(180deg,var(--bg),#eef3fb 60%);
    color:#111827;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  .container{
    max-width:980px;
    margin:0 auto;
    padding:20px;
  }
  header{
    display:flex;
    align-items:center;
    gap:16px;
    margin-bottom:18px;
  }
  h1{
    font-size:20px;
    margin:0;
  }
  .meta{
    color:var(--muted);
    font-size:13px;
  }

  .puzzle-card{
    background:var(--card);
    border-radius:10px;
    box-shadow:0 6px 20px rgba(15,23,42,0.06);
    padding:18px;
    margin-bottom:18px;
    border:1px solid rgba(15,23,42,0.04);
  }

  .desc{
    background:linear-gradient(90deg,#fff,#fbfdff);
    padding:12px;
    border-radius:8px;
    border:1px dashed rgba(11,97,214,0.08);
    margin-bottom:12px;
  }
  .desc p{margin:6px 0;color:#0f172a;font-size:14px}
  .example{color:var(--muted);font-size:13px;margin-top:6px}

  /* pseudocode area */
  .code-wrap{
    background:#0f172a;
    color:#e6eef8;
    border-radius:8px;
    padding:12px;
    font-family: "Courier New", Courier, monospace;
    font-size:14px;
    overflow:auto;
    line-height:1.6;
  }
  .code-line{
    white-space:pre;
  }
  .blank {
    display:inline-block;
    min-width:48px;
    padding:2px 6px;
    margin:0 2px;
    border-radius:6px;
    background:rgba(255,255,255,0.07);
    color:#fff;
    border:2px dashed rgba(255,255,255,0.08);
    outline: none;
    cursor:pointer;
    vertical-align:baseline;
  }
  .blank:focus { box-shadow:0 0 0 3px rgba(255,183,3,0.14); border-color:var(--focus);}
  .blank.empty{ color:#cbd5e1; font-style:italic;}
  .blank.correct { background:rgba(22,163,74,0.18); border-color:rgba(22,163,74,0.5); color:var(--success); }
  .blank.incorrect { background:rgba(239,68,68,0.12); border-color:rgba(239,68,68,0.3); color:var(--danger); }

  /* bank */
  .bank{
    margin-top:12px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    background:var(--bank-bg);
    padding:10px;
    border-radius:8px;
    border:1px solid rgba(11,97,214,0.06);
  }
  .token{
    user-select:none;
    padding:8px 10px;
    border-radius:8px;
    background:#fff;
    border:1px solid rgba(2,6,23,0.06);
    box-shadow:0 2px 6px rgba(2,6,23,0.04);
    font-weight:600;
    font-size:13px;
    cursor:grab;
  }
  .token:active{ cursor:grabbing }
  .token[aria-pressed="true"]{ outline:3px solid rgba(11,97,214,0.14); box-shadow:0 6px 18px rgba(11,97,214,0.08); }
  .token:focus { box-shadow:0 0 0 3px rgba(11,97,214,0.10); outline:none; }

  /* controls */
  .controls{
    display:flex;
    gap:10px;
    margin-top:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  button{
    padding:9px 14px;
    border-radius:8px;
    border:0;
    font-weight:600;
    background:var(--accent);
    color:white;
    cursor:pointer;
    box-shadow:0 6px 18px rgba(11,97,214,0.10);
  }
  button.secondary{
    background:#fff; color:var(--accent); border:1px solid rgba(11,97,214,0.10);
    box-shadow:none;
  }
  button.ghost{
    background:transparent; color:var(--muted); border:1px dashed rgba(2,6,23,0.06);
  }
  .msg{ margin-left:8px; color:var(--muted); font-weight:600; }

  /* small screens */
  @media (max-width:640px){
    .container{ padding:12px; }
    header{ gap:8px; }
    .code-wrap{ font-size:13px; }
    .token{ font-size:12px; padding:7px 9px; }
    button{ padding:8px 10px; font-size:14px; }
  }

  /* focus outlines for keyboard users */
  :focus { outline: none; }
  .a11y-focus { box-shadow:0 0 0 3px rgba(255,183,3,0.14); border-radius:6px; }

  /* subtle helper text */
  .help{ color:var(--muted); font-size:13px; margin-top:10px;}
</style>
</head>
<body>
<div class="container" id="app">
  <header>
    <div>
      <h1>Fill in the missing code â€” Conditionals</h1>
      <div class="meta">Drag or click tokens into blanks. Press Enter to place when using keyboard.</div>
    </div>
  </header>

  <main>
    <section class="puzzle-card" id="puzzleCard" aria-live="polite">
      <div class="desc" id="descBox" role="region" aria-label="Puzzle description"></div>

      <div class="code-wrap" id="codeWrap" role="region" aria-label="Pseudocode area">
        <!-- lines inserted here -->
      </div>

      <div class="bank" id="bank" aria-label="Word bank" role="listbox" tabindex="0"></div>

      <div class="controls" style="justify-content:flex-start;">
        <button id="submitBtn">Submit</button>
        <button class="secondary" id="resetBtn">Reset (reshuffle)</button>
        <button class="ghost" id="nextBtn">Next Puzzle â†’</button>
        <div class="msg" id="feedback" aria-live="assertive"></div>
      </div>

      <div class="help">Keyboard: Tab to a token, press Enter to pick; Tab to a blank, press Enter to place. Use Escape to clear selection.</div>
    </section>

    <p style="color:var(--muted);font-size:13px;margin-top:8px">
      The puzzles are easy to edit in the source: see the <code>puzzles</code> array at the end of the JS.
    </p>
  </main>
</div>

<script>
/*
  Single-file pseudocode puzzles.
  - Puzzles are defined in the `puzzles` array.
  - Each puzzle has:
      title, description, example (optional),
      lines: array of strings (each line is code, no indentation),
      bank: array of tokens to show,
      solution: object mapping blankNumber (1-based) -> correct token (exact match, case-sensitive)
*/

(function(){
  // Utility: shuffle array in place
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  // --- Puzzle definitions (progressively harder) ---
  const puzzles = [
    // 1: easy (2 blanks)
    {
      title: "Basic IF â€” positive check",
      description: "Read an integer and output whether it is positive. Input: one number. Output: a short message when the number is positive.",
      example: "If the input is 5 the program should output: The number is positive",
      lines: [
"BEGIN",
"INPUT number",
"IF number ___1___ 0 ___2___",
"OUTPUT \"The number is positive\"",
"ENDIF",
"END"
      ],
      bank: ["THEN", ">", "<", "ELSE"],
      solution: {1: ">", 2: "THEN"}
    },

    // 2: small step up (3 blanks)
    {
      title: "IF-ELSE â€” even or odd (MOD)",
      description: "Read an integer and print whether it is even or odd. Use the MOD operator to test divisibility. Fill the operator, equality and THEN.",
      example: "Input 4 -> outputs: Even",
      lines: [
"BEGIN",
"INPUT n",
"IF n ___1___ 2 ___2___ 0 ___3___",
"OUTPUT \"Even\"",
"ELSE",
"OUTPUT \"Odd\"",
"ENDIF",
"END"
      ],
      bank: ["MOD","THEN","=","ELSE","%","<>"],
      solution: {1: "MOD", 2: "=", 3: "THEN"}
    },

    // 3: nested (single nested) â€” more blanks (4)
    {
      title: "Nested IF-ELSE (single nested) â€” positive & large",
      description: "Read a number. If it is positive, check whether it is larger than 100 and respond. This puzzle has one nested IF-ELSE.",
      example: "Input 150 -> outputs: Large and positive",
      lines: [
"BEGIN",
"INPUT x",
"IF x ___1___ 0 ___2___",
"IF x ___3___ 100 ___4___",
"OUTPUT \"Large and positive\"",
"ELSE",
"OUTPUT \"Positive but not large\"",
"ENDIF",
"ELSE",
"OUTPUT \"Not positive\"",
"ENDIF",
"END"
      ],
      bank: [">","THEN","<","ELSE","="],
      solution: {1: ">", 2: "THEN", 3: ">", 4: "THEN"}
    },

    // 4: IF with ELSE (simple classification) â€” 3 blanks
    {
      title: "IF with ELSE â€” zero or not",
      description: "Read a number and report if it is zero or not zero. Fill in the comparison and THEN.",
      example: "Input 0 -> outputs: Zero",
      lines: [
"BEGIN",
"INPUT number",
"IF number ___1___ 0 ___2___",
"OUTPUT \"Zero\"",
"ELSE",
"OUTPUT \"Not zero\"",
"ENDIF",
"END"
      ],
      bank: ["THEN","=","MOD","ELSE","<>"],
      solution: {1: "=", 2: "THEN"}
    },

    // 5: Basic CASE â€” more blanks & distractors (4 blanks)
    {
      title: "Basic CASE â€” options",
      description: "Read a code and select one of three options. Use CASE with OF and DEFAULT. Fill the CASE structure tokens.",
      example: "Input 2 -> outputs: Option Two",
      lines: [
"BEGIN",
"INPUT code",
"___1___ code ___2___",
"1: OUTPUT \"Option One\"",
"2: OUTPUT \"Option Two\"",
"3: OUTPUT \"Option Three\"",
"___3___: OUTPUT \"Unknown\"",
"___4___",
"END"
      ],
      bank: ["CASE","OF","DEFAULT","ENDCASE","WHEN","SWITCH"],
      solution: {1: "CASE", 2: "OF", 3: "DEFAULT", 4: "ENDCASE"}
    },

    // 6: CASE inside IF â€” more blanks in conditions (5 blanks)
    {
      title: "CASE inside IF â€” admin message",
      description: "If admin is 1 show a CASE with specific admin welcome messages. Fill in the IF THEN, CASE tokens, and ENDCASE.",
      example: "Input admin=1 and code=1 -> outputs: Welcome, superadmin",
      lines: [
"BEGIN",
"INPUT admin",
"INPUT code",
"IF admin ___1___ 1 ___2___",
"CASE code ___3___",
"1: OUTPUT \"Welcome, superadmin\"",
"2: OUTPUT \"Welcome, admin\"",
"___4___: OUTPUT \"Welcome\"",
"___5___",
"ENDIF",
"END"
      ],
      bank: ["=","THEN","OF","DEFAULT","ENDCASE","<>","ELSE"],
      solution: {1: "=", 2: "THEN", 3: "OF", 4: "DEFAULT", 5: "ENDCASE"}
    },

    // 7: IF with CASEs in both branches â€” 5 blanks
    {
      title: "IF with CASEs in both branches",
      description: "If userType = 1 run a CASE for admin options; otherwise run a CASE for guest options. Fill THEN and CASE tokens.",
      example: "userType=2 and choice=1 -> outputs: Guest: View",
      lines: [
"BEGIN",
"INPUT userType",
"INPUT choice",
"IF userType ___1___ 1 ___2___",
"CASE choice ___3___",
"1: OUTPUT \"Admin: Edit\"",
"2: OUTPUT \"Admin: Delete\"",
"DEFAULT: OUTPUT \"Admin: Unknown\"",
"___4___",
"ELSE",
"CASE choice ___5___",
"1: OUTPUT \"Guest: View\"",
"2: OUTPUT \"Guest: Browse\"",
"DEFAULT: OUTPUT \"Guest: Unknown\"",
"___6___",
"ENDIF",
"END"
      ],
      bank: ["=","THEN","OF","ENDCASE","ELSE","CASE","DEFAULT","END"],
      solution: {1: "=", 2: "THEN", 3: "OF", 4: "ENDCASE", 5: "OF", 6: "ENDCASE"}
    },

    // 8: Two separate IF-ELSE statements â€” increased blanks and distractors (5 blanks)
    {
      title: "Two separate IF-ELSE statements (independent)",
      description: "Read temperature and windSpeed. Check two independent conditions and output messages for each. Fill relational operators and THENs.",
      example: "temp=30 -> 'Hot'; windSpeed=25 -> 'Windy'",
      lines: [
"BEGIN",
"INPUT temp",
"INPUT windSpeed",
"IF temp ___1___ 25 ___2___",
"OUTPUT \"Hot\"",
"ELSE",
"OUTPUT \"Not hot\"",
"ENDIF",
"IF windSpeed ___3___ 20 ___4___",
"OUTPUT \"Windy\"",
"ELSE",
"OUTPUT \"Calm\"",
"ENDIF",
"END"
      ],
      bank: [">","THEN","MOD","<","=","ELSE","<>"],
      solution: {1: ">", 2: "THEN", 3: ">", 4: "THEN"}
    },

    // 9: IF using SUBSTRING â€” include literal token blank and more distractors (5 blanks)
    {
      title: "IF using SUBSTRING â€” prefix check",
      description: "Read a word. If its first three letters are 'pre' output a message. Fill SUBSTRING, equality, literal and THEN.",
      example: "Input 'prefix' -> outputs: Starts with pre",
      lines: [
"BEGIN",
"INPUT word",
"IF ___1___(word,1,3) ___2___ ___3___ ___4___",
"OUTPUT \"Starts with pre\"",
"ELSE",
"OUTPUT \"Different prefix\"",
"ENDIF",
"END"
      ],
      bank: ["SUBSTRING","=","\"pre\"","THEN","ELSE","LEFT","MID"],
      solution: {1: "SUBSTRING", 2: "=", 3: "\"pre\"", 4: "THEN"}
    },

    // 10: Final complex â€” many blanks, more than half of code missing (hard)
    {
      title: "Final: CASE + SUBSTRING + ROUND (hard)",
      description: "Read a name and a score. If the name prefix matches, greet; otherwise round the score and use a CASE. This final puzzle has many blanks â€” more than half of the code tokens are missing.",
      example: "name='Ann'; score=4.6 -> rounded 5 -> outputs: Excellent",
      lines: [
"___1___",
"___2___ name",
"___3___ score",
"IF ___4___(name,1,3) ___5___ ___6___",
"___7___ \"Hello Ann\"",
"ELSE",
"___8___Rounded <- ___9___(score)",
"CASE ___10___ ___11___",
"5: ___12___ \"Excellent\"",
"4: ___13___ \"Good\"",
"DEFAULT: ___14___ \"Keep trying\"",
"___15___",
"___16___",
"END"
      ],
      // bank contains all correct tokens + many distractors to increase confusion
      bank: [
        "BEGIN","INPUT","OUTPUT","SUBSTRING","=","\"Ann\"","THEN","OUTPUT","ELSE",
        "scoreRounded","ROUND","OF","ENDCASE","CASE","END","DEFAULT",
        "PRINT","RANDOM","SUBSTR","->","LET","<-","ELIF"
      ],
      // mapping blankNumber -> exact token (case-sensitive)
      solution: {
        1: "BEGIN",
        2: "INPUT",
        3: "INPUT",
        4: "SUBSTRING",
        5: "=",
        6: "THEN",
        7: "OUTPUT",
        8: "scoreRounded <-",
        9: "ROUND",
        10: "scoreRounded",
        11: "OF",
        12: "OUTPUT",
        13: "OUTPUT",
        14: "OUTPUT",
        15: "ENDCASE",
        16: "ENDIF"
      }
    }
  ];
  // --- end puzzles ---

  // Application state
  let puzzleIndex = 0;
  let currentPuzzle = null;
  let bankTokens = []; // tokens currently in bank (strings)
  let blankState = {};  // mapping blankNumber -> token or null
  let selectedTokenIndex = null; // index in bankTokens of selected token when user clicks (null when none)
  const app = document.getElementById('app');
  const descBox = document.getElementById('descBox');
  const codeWrap = document.getElementById('codeWrap');
  const bankEl = document.getElementById('bank');
  const feedbackEl = document.getElementById('feedback');
  const submitBtn = document.getElementById('submitBtn');
  const resetBtn = document.getElementById('resetBtn');
  const nextBtn = document.getElementById('nextBtn');

  // Load initial puzzle
  function loadPuzzle(index){
    puzzleIndex = index % puzzles.length;
    currentPuzzle = JSON.parse(JSON.stringify(puzzles[puzzleIndex])); // deep copy to avoid accidental edits
    // Normalize lines: if solution contains tokens like "scoreRounded <-" that's a single token; keep as-is.
    bankTokens = shuffle(currentPuzzle.bank.slice()); // copy & shuffle
    blankState = {};
    // Count blanks in lines to initialize mapping
    const allBlanks = extractBlanksFromLines(currentPuzzle.lines);
    allBlanks.forEach(num => { blankState[num] = null; });
    // Render UI
    renderDescription();
    renderCode();
    renderBank();
    feedbackEl.textContent = '';
    selectedTokenIndex = null;
    // Announce puzzle to screen readers
    codeWrap.setAttribute('aria-label', currentPuzzle.title + ". " + (currentPuzzle.description || ""));
  }

  // Extract blank numbers present in lines (array of ints)
  function extractBlanksFromLines(lines){
    const nums = [];
    const re = /___(\d+)___/g;
    lines.forEach(line=>{
      let m;
      while((m=re.exec(line))!==null){
        nums.push(Number(m[1]));
      }
    });
    // Deduplicate & sort
    return Array.from(new Set(nums)).sort((a,b)=>a-b);
  }

  // Render description
  function renderDescription(){
    descBox.innerHTML = '';
    const h = document.createElement('div');
    const title = document.createElement('strong');
    title.textContent = currentPuzzle.title;
    h.appendChild(title);
    const p = document.createElement('p');
    p.textContent = currentPuzzle.description || '';
    h.appendChild(p);
    if(currentPuzzle.example){
      const ex = document.createElement('div');
      ex.className = 'example';
      ex.textContent = "Example: " + currentPuzzle.example;
      h.appendChild(ex);
    }
    descBox.appendChild(h);
  }

  // Render code area with blanks turned into focusable blank elements
  function renderCode(){
    codeWrap.innerHTML = '';
    currentPuzzle.lines.forEach((line, lineIdx) => {
      const lineDiv = document.createElement('div');
      lineDiv.className = 'code-line';
      const re = /___(\d+)___/g;
      let lastIndex = 0;
      let match;
      const frag = document.createDocumentFragment();
      while((match = re.exec(line)) !== null){
        const before = line.slice(lastIndex, match.index);
        if(before) frag.appendChild(document.createTextNode(before));
        const bnum = match[1];
        const span = document.createElement('button');
        span.type = 'button';
        span.className = 'blank empty';
        span.setAttribute('data-blank', bnum);
        span.setAttribute('aria-label', 'Blank ' + bnum + '. Press Enter to place token.');
        span.setAttribute('tabindex', '0');
        span.textContent = '___' + bnum + '___';
        span.addEventListener('click', ()=> onBlankClick(bnum, span));
        span.addEventListener('keydown', (ev)=> {
          if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); onBlankClick(bnum, span); }
          else if(ev.key === 'Escape'){ clearSelection(); }
        });
        frag.appendChild(span);
        lastIndex = re.lastIndex;
      }
      if(lastIndex < line.length){
        frag.appendChild(document.createTextNode(line.slice(lastIndex)));
      }
      lineDiv.appendChild(frag);
      codeWrap.appendChild(lineDiv);
    });
    updateBlankDisplays();
  }

  // Render bank tokens
  function renderBank(){
    bankEl.innerHTML = '';
    bankEl.setAttribute('aria-label', 'Word bank. ' + bankTokens.length + ' tokens.');
    bankTokens.forEach((tok, idx) => {
      const t = document.createElement('div');
      t.className = 'token';
      t.setAttribute('role','option');
      t.setAttribute('tabindex','0');
      t.setAttribute('draggable','true');
      t.setAttribute('data-index', idx);
      t.setAttribute('data-token', tok);
      t.textContent = tok;
      t.addEventListener('dragstart', onTokenDragStart);
      t.addEventListener('click', ()=> onTokenClick(idx, t));
      t.addEventListener('keydown', (ev) => {
        if(ev.key === 'Enter' || ev.key === ' '){
          ev.preventDefault();
          onTokenClick(idx, t);
        } else if(ev.key === 'Escape'){
          clearSelection();
        }
      });
      bankEl.appendChild(t);
    });
    // Make blanks droppable
    const blanks = codeWrap.querySelectorAll('.blank');
    blanks.forEach(b => {
      b.addEventListener('dragover', onBlankDragOver);
      b.addEventListener('drop', onBlankDrop);
      b.addEventListener('dragstart', onBlankDragStart);
      b.setAttribute('draggable','false');
    });
  }

  // Update blank visuals based on blankState
  function updateBlankDisplays(){
    const blanks = codeWrap.querySelectorAll('.blank');
    blanks.forEach(b => {
      const bnum = Number(b.getAttribute('data-blank'));
      const val = blankState[bnum];
      b.classList.remove('empty','correct','incorrect');
      if(val === null || typeof val === 'undefined'){
        b.classList.add('empty');
        b.textContent = '___' + bnum + '___';
        b.setAttribute('aria-label','Blank ' + bnum + '. empty.');
      } else {
        b.textContent = val;
        b.classList.remove('empty');
        b.setAttribute('aria-label','Blank ' + bnum + '. contains token ' + val + '.');
      }
    });
    refreshBankVisualSelection();
  }

  // --- Drag and drop handlers ---
  let draggedTokenIndex = null; // index in bankTokens while dragging
  function onTokenDragStart(ev){
    const idx = Number(ev.target.getAttribute('data-index'));
    draggedTokenIndex = idx;
    ev.dataTransfer.setData('text/plain', String(idx));
    ev.dataTransfer.effectAllowed = 'move';
  }

  function onBlankDragOver(ev){
    ev.preventDefault();
    ev.dataTransfer.dropEffect = 'move';
  }

  function onBlankDrop(ev){
    ev.preventDefault();
    const target = ev.currentTarget;
    const bnum = Number(target.getAttribute('data-blank'));
    let idx = null;
    const dt = ev.dataTransfer.getData('text/plain');
    if(dt){
      idx = Number(dt);
    } else {
      idx = draggedTokenIndex;
    }
    if(typeof idx !== 'number' || isNaN(idx)) return;
    placeTokenIntoBlank(idx, bnum);
    draggedTokenIndex = null;
  }

  // Drag from blank back to bank
  function onBlankDragStart(ev){
    const b = ev.currentTarget;
    const bnum = Number(b.getAttribute('data-blank'));
    const token = blankState[bnum];
    if(token){
      ev.dataTransfer.setData('text/plain', 'blank:' + bnum);
      ev.dataTransfer.effectAllowed = 'move';
      blankState[bnum] = null;
      updateBlankDisplays();
      bankTokens.push(token);
      renderBank();
    } else {
      ev.preventDefault();
    }
  }

  // Click-to-pick for tokens
  function onTokenClick(index, el){
    if(selectedTokenIndex === index){
      clearSelection();
      return;
    }
    selectedTokenIndex = index;
    refreshBankVisualSelection();
  }

  function refreshBankVisualSelection(){
    const tokens = bankEl.querySelectorAll('.token');
    tokens.forEach(t => {
      const idx = Number(t.getAttribute('data-index'));
      if(selectedTokenIndex === idx){
        t.setAttribute('aria-pressed','true');
        t.classList.add('selected');
      } else {
        t.setAttribute('aria-pressed','false');
        t.classList.remove('selected');
      }
    });
  }

  // Blank click handlers
  function onBlankClick(bnum, element){
    if(selectedTokenIndex !== null && bankTokens[selectedTokenIndex] !== undefined){
      placeTokenIntoBlank(selectedTokenIndex, Number(bnum));
      clearSelection();
      return;
    }
    const current = blankState[bnum];
    if(current){
      blankState[bnum] = null;
      bankTokens.push(current);
      shuffle(bankTokens);
      renderBank();
      updateBlankDisplays();
      feedbackEl.textContent = '';
      return;
    }
  }

  // Place token into blank
  function placeTokenIntoBlank(bankIndex, bnum){
    const token = bankTokens[bankIndex];
    if(typeof token === 'undefined') return;
    const prev = blankState[bnum];
    if(prev){
      bankTokens.push(prev);
    }
    blankState[bnum] = token;
    bankTokens.splice(bankIndex,1);
    renderBank();
    updateBlankDisplays();
    feedbackEl.textContent = '';
  }

  // Clear selection
  function clearSelection(){
    selectedTokenIndex = null;
    refreshBankVisualSelection();
  }

  // Reset puzzle
  function resetPuzzle(){
    Object.keys(blankState).forEach(k=>{
      const tok = blankState[k];
      if(tok) bankTokens.push(tok);
      blankState[k] = null;
    });
    bankTokens = shuffle(bankTokens);
    renderBank();
    updateBlankDisplays();
    feedbackEl.textContent = 'Bank reshuffled. Fill the blanks again.';
    clearSelection();
  }

  // Submit
  function submitPuzzle(){
    const solution = currentPuzzle.solution || {};
    let allCorrect = true;
    const blanks = Object.keys(blankState).map(n => Number(n));
    blanks.forEach(n=>{
      const placed = blankState[n];
      const expected = solution[n];
      const element = codeWrap.querySelector('.blank[data-blank="'+n+'"]');
      element.classList.remove('correct','incorrect');
      if(placed === expected && typeof expected !== 'undefined'){
        element.classList.add('correct');
      } else {
        element.classList.add('incorrect');
        allCorrect = false;
      }
    });
    if(allCorrect){
      feedbackEl.textContent = "All correct! Well done ðŸŽ‰";
    } else {
      feedbackEl.textContent = "Some blanks are incorrect â€” incorrect blanks are highlighted red.";
    }
  }

  // Next
  function nextPuzzle(){
    const nextIndex = (puzzleIndex + 1) % puzzles.length;
    loadPuzzle(nextIndex);
    feedbackEl.textContent = '';
  }

  // Initial bindings
  submitBtn.addEventListener('click', submitPuzzle);
  resetBtn.addEventListener('click', resetPuzzle);
  nextBtn.addEventListener('click', nextPuzzle);

  document.addEventListener('keydown', (ev) => {
    if(ev.key === 'Escape'){
      clearSelection();
    }
  });

  // Initialize first puzzle
  loadPuzzle(0);

  // Allow dropping blank tokens back to bank
  bankEl.addEventListener('dragover', (ev)=> { ev.preventDefault(); ev.dataTransfer.dropEffect = 'move'; });
  bankEl.addEventListener('drop', (ev)=>{
    ev.preventDefault();
    const data = ev.dataTransfer.getData('text/plain') || '';
    if(data.startsWith('blank:')){
      const bnum = Number(data.split(':')[1]);
      const tok = blankState[bnum];
      if(tok){
        bankTokens.push(tok);
        blankState[bnum] = null;
        renderBank();
        updateBlankDisplays();
      }
    }
  });

  // Expose simple helper for teachers to jump puzzle by index (optional)
  window._puzzleControls = {
    goTo: (i)=> loadPuzzle(i % puzzles.length),
    listCount: () => puzzles.length
  };

})();
</script>
</body>
</html>
