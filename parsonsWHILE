<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Parsons — WHILE DO (Reorder mode)</title>
<style>
  :root{
    --bg:#f6f8fb; --card:#fff; --accent:#0568d6; --ok:#e6fbec; --bad:#ffecec;
    --border:#dfe7f2; --muted:#556;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); margin:20px; color:#122;}
  .container{max-width:960px;margin:0 auto;}
  header{display:flex;align-items:center;gap:16px;}
  h1{margin:0;font-size:20px;}
  .panel{background:var(--card);border:1px solid var(--border);padding:12px;border-radius:10px;margin-top:12px;}
  .desc-box{border-radius:8px;padding:10px;border:1px solid #e2e8f0;background:#fff;margin-bottom:12px;}
  .desc-title{font-weight:700;margin-bottom:6px;}
  .desc-list{margin:6px 0 0 18px;color:#123;}
  .example{font-family:monospace;background:#f3f9ff;padding:8px;border-radius:6px;border:1px solid #dbeeff;margin-top:8px;white-space:pre-wrap;}
  .code-box{min-height:160px;border:2px dashed var(--border);background:#fff;padding:12px;border-radius:8px;display:flex;flex-direction:column;gap:8px;}
  .block{user-select:none;padding:10px 12px;border-radius:8px;background:#f9fbff;border:1px solid #d0d9ef;cursor:grab;min-width:220px;box-shadow:0 1px 0 rgba(0,0,0,0.02);transition:transform .12s ease, background .18s;}
  .block.dragging{opacity:0.6;transform:scale(0.98);}
  .block.correct{background:var(--ok);border-color:#80d08a;}
  .block.incorrect{background:var(--bad);border-color:#f3a3a3;}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px;}
  button{padding:8px 12px;border-radius:8px;border:0;font-weight:700;cursor:pointer;}
  .btn-primary{background:var(--accent);color:white;}
  .btn-secondary{background:#657; color:#fff; opacity:0.95}
  .btn-ghost{background:#eef2f7;color:#223;border:1px solid #d6e0f4;}
  select{padding:6px;border-radius:8px;border:1px solid #d7e0f5;}
  #message{margin-top:10px;font-weight:700;color:#444;}
  @media (max-width:700px){
    .block{min-width:150px;}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Parsons — WHILE DO (Reorder mode)</h1>
    </header>

    <div class="panel" id="puzzlePanel">
      <div class="desc-box" id="descriptionBox">
        <div class="desc-title" id="descTitle">Select a puzzle</div>
        <ul class="desc-list" id="descBullets"></ul>
        <div id="exampleBox" class="example" style="display:none;"></div>
      </div>

      <div id="codeBox" class="code-box" aria-label="Scrambled code lines" tabindex="0"></div>

      <div class="controls" style="justify-content:flex-start;">
        <button id="submitBtn" class="btn-primary">Submit</button>
        <button id="revealHintBtn" class="btn-ghost">Reveal hint (3 left)</button>
        <button id="resetBtn" class="btn-secondary">Reset (Reshuffle)</button>
        <button id="nextBtn" class="btn-ghost">Next Puzzle</button>
        <div style="margin-left:auto;">
          <label> Puzzle:
            <select id="puzzleSelect"></select>
          </label>
        </div>
      </div>

      <div id="message"></div>
    </div>
  </div>

<script>
/* Parsons WHILE DO — stable, single-listener version.
   Fixes: container-level dragover registered once (in init), safer reveal hint for duplicates,
   checker compares visible text, and avoids double-registering event handlers.
*/

const MAX_HINTS_PER_PUZZLE = 3;

const puzzles = [ /* puzzles array omitted in this snippet for brevity */ ];

// --- paste the puzzles array here programmatically by reusing existing content ---

// Instead of duplicating, we'll build the puzzles array dynamically from the existing DOM
// But since the canvas requires a full HTML file, we must include the puzzles inline.
// For safety, the full puzzles array is reinserted below.

// (BEGIN FULL PUZZLES ARRAY)
const fullPuzzles = [
  {
    title: "Increment counter from 1 to 5",
    bullets: ["No input — print numbers 1 to 5, each on its own line."],
    example: "1\n2\n3\n4\n5",
    lines: [
      "Counter ← 1",
      "WHILE Counter <= 5 DO",
      "OUTPUT Counter",
      "Counter ← Counter + 1",
      "ENDWHILE"
    ]
  },
  {
    title: "Greet names until STOP",
    bullets: ["Keep asking for a name until the user types STOP (case-sensitive)."],
    example: "Input: Alice, Bob, STOP → Output: Hello Alice\nHello Bob",
    lines: [
      "INPUT Name",
      "WHILE Name <> \"STOP\" DO",
      "OUTPUT \"Hello \", Name",
      "INPUT Name",
      "ENDWHILE"
    ]
  },
  {
    title: "Running total of positive numbers",
    bullets: ["Keep a running total of positive numbers; stop when a non-positive is entered."],
    example: "Input: 5, 10, -2 → Output: The total is 15",
    lines: [
      "Total ← 0",
      "INPUT Number",
      "WHILE Number > 0 DO",
      "Total ← Total + Number",
      "INPUT Number",
      "ENDWHILE",
      "OUTPUT \"The total is \", Total"
    ]
  },
  {
    title: "Countdown from 10 to 1",
    bullets: ["No input — count down from 10 to 1 and then print 'Blast off!'"],
    example: "10..1 then Blast off!",
    lines: [
      "Count ← 10",
      "WHILE Count >= 1 DO",
      "OUTPUT Count",
      "Count ← Count - 1",
      "ENDWHILE",
      "OUTPUT \"Blast off!\""
    ]
  },
  {
    title: "Password check until correct",
    bullets: ["Keep asking for a password until the correct one is entered."],
    example: "Input wrong → 'Try again'; Input Secret123 → 'Access granted'",
    lines: [
      "Correct ← FALSE",
      "WHILE Correct = FALSE DO",
      "INPUT Password",
      "IF Password = \"Secret123\" THEN",
      "OUTPUT \"Access granted\"",
      "Correct ← TRUE",
      "ELSE",
      "OUTPUT \"Try again\"",
      "ENDIF",
      "ENDWHILE"
    ]
  },
  {
    title: "Multiply until > 100",
    bullets: ["Start from a number and multiply by 2 until it exceeds 100 (include outputs)."],
    example: "5,10,20,40,80,160 (stop after exceeding 100)",
    lines: [
      "Number ← 5",
      "WHILE Number <= 100 DO",
      "OUTPUT Number",
      "Number ← Number * 2",
      "ENDWHILE"
    ]
  },
  {
    title: "Sum only even numbers",
    bullets: ["Read numbers until 0; add only even numbers to the sum."],
    example: "Input 4,3,2,0 → Sum of even numbers is 6",
    lines: [
      "Sum ← 0",
      "INPUT Number",
      "WHILE Number <> 0 DO",
      "IF Number MOD 2 = 0 THEN",
      "Sum ← Sum + Number",
      "ENDIF",
      "INPUT Number",
      "ENDWHILE",
      "OUTPUT \"Sum of even numbers is \", Sum"
    ]
  },
  {
    title: "Print multiplication table until 0",
    bullets: ["Keep printing the 1..5 table for entered numbers until user enters 0."],
    example: "Input 3 → prints 3 x 1 = 3 ... 3 x 5 = 15; Input 0 → stop",
    lines: [
      "INPUT Number",
      "WHILE Number <> 0 DO",
      "FOR i ← 1 TO 5",
      "OUTPUT Number, \" x \", i, \" = \", Number * i",
      "NEXT i",
      "INPUT Number",
      "ENDWHILE"
    ]
  },
  {
    title: "Loop while count ≤ 5 AND total < 100",
    bullets: ["Keep reading numbers while both conditions hold; stop otherwise."],
    example: "Reads up to 5 numbers or until total≥100; then outputs the final total.",
    lines: [
      "Count ← 1",
      "Total ← 0",
      "WHILE Count <= 5 AND Total < 100 DO",
      "INPUT Number",
      "Total ← Total + Number",
      "Count ← Count + 1",
      "ENDWHILE",
      "OUTPUT \"Final total is \", Total"
    ]
  },
  {
  title: "Nested WHILE loops for student marks",
  bullets: [
    "This program uses two WHILE loops — one inside the other.",
    "The outer WHILE loop repeats for each student (3 students in total).",
    "The inner WHILE loop repeats for each subject (2 subjects per student).",
    "For every subject of every student, ask the user to enter a mark.",
    "After all marks are entered, print 'All marks entered'."
  ],
  example: "Expected sequence:\nStudent 1 Subject 1 → input mark\nStudent 1 Subject 2 → input mark\nStudent 2 Subject 1 → input mark\nStudent 2 Subject 2 → input mark\nStudent 3 Subject 1 → input mark\nStudent 3 Subject 2 → input mark\nThen: All marks entered",
  lines: [
    "Student ← 1",
    "WHILE Student <= 3 DO",
    "Subject ← 1",
    "WHILE Subject <= 2 DO",
    "OUTPUT \"Enter mark for Student \", Student, \" Subject \", Subject",
    "INPUT Mark",
    "Subject ← Subject + 1",
    "ENDWHILE",
    "Student ← Student + 1",
    "ENDWHILE",
    "OUTPUT \"All marks entered\""
  ]
}

];
// (END FULL PUZZLES ARRAY)

// DOM refs
const codeBox = document.getElementById('codeBox');
const descTitle = document.getElementById('descTitle');
const descBullets = document.getElementById('descBullets');
const exampleBox = document.getElementById('exampleBox');
const puzzleSelect = document.getElementById('puzzleSelect');
const submitBtn = document.getElementById('submitBtn');
const revealHintBtn = document.getElementById('revealHintBtn');
const resetBtn = document.getElementById('resetBtn');
const nextBtn = document.getElementById('nextBtn');
const messageEl = document.getElementById('message');

let current = 0;
let pickedBlock = null;
const usedHintsCount = {}; // in-memory per puzzle

// helpers
function shuffleArray(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function populatePuzzleSelect(){
  puzzleSelect.innerHTML = '';
  fullPuzzles.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i+1}. ${p.title}`;
    puzzleSelect.appendChild(opt);
  });
  puzzleSelect.value = 0;
}

function renderDescription(idx){
  const p = fullPuzzles[idx];
  descTitle.textContent = p.title;
  descBullets.innerHTML = '';
  p.bullets.forEach(b=>{
    const li = document.createElement('li');
    li.textContent = b;
    descBullets.appendChild(li);
  });
  if(p.example && p.example.trim() !== ''){
    exampleBox.style.display = 'block';
    exampleBox.innerHTML = `<div style="font-weight:600; margin-bottom:4px;">Expected Output</div>${p.example}`;
  } else {
    exampleBox.style.display = 'none';
    exampleBox.innerHTML = '';
  }
  updateRevealHintBtn();
}

// improved drag helpers
function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.block:not(.dragging)')];
  let closest = null;
  let closestOffset = Number.NEGATIVE_INFINITY;
  for (const el of draggableElements) {
    const box = el.getBoundingClientRect();
    const offset = y - (box.top + box.height / 2);
    if (offset < 0 && offset > closestOffset) {
      closestOffset = offset;
      closest = el;
    }
  }
  return closest;
}

function setNoSelect(on) {
  if (on) {
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
  } else {
    document.body.style.userSelect = '';
    document.body.style.webkitUserSelect = '';
  }
}

// build code box
function buildCodeBox(idx){
  codeBox.innerHTML = '';
  const p = fullPuzzles[idx];
  const items = p.lines.map((line, i) => ({line, idx:i}));
  const shuffled = items.slice();
  shuffleArray(shuffled);

  shuffled.forEach(item => {
    const el = document.createElement('div');
    el.className = 'block';
    el.draggable = true;
    el.tabIndex = 0;
    el.dataset.id = `line-${item.idx}-${Math.random().toString(36).slice(2,9)}`;
    el.dataset.origIndex = String(item.idx);
    el.textContent = item.line;

    el.addEventListener('dragstart', e => {
      el.classList.add('dragging');
      e.dataTransfer.setData('text/plain', el.dataset.id);
      e.dataTransfer.effectAllowed = 'move';
      setNoSelect(true);
    });
    el.addEventListener('dragend', () => {
      el.classList.remove('dragging');
      setNoSelect(false);
    });

    el.addEventListener('click', onBlockClick);
    codeBox.appendChild(el);
  });

  // clear visual marks
  Array.from(codeBox.children).forEach(c => c.classList.remove('correct','incorrect'));
  messageEl.textContent = '';
  updateRevealHintBtn();
}

function onBlockClick(e){
  const el = e.currentTarget;
  if(!pickedBlock){
    pickedBlock = el;
    el.style.outline = '3px solid rgba(5,104,214,0.18)';
    return;
  }
  if(pickedBlock === el){
    pickedBlock.style.outline = '';
    pickedBlock = null;
    return;
  }
  codeBox.insertBefore(pickedBlock, el);
  el.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}], {duration:120});
  pickedBlock.style.outline = '';
  pickedBlock = null;
}

// check order: compare visible text to expected text for that position
function checkOrder(){
  const p = fullPuzzles[current];
  const expected = p.lines.map(s => s.trim());
  const children = Array.from(codeBox.children);
  let allCorrect = true;
  children.forEach((c, i) => {
    const actual = c.textContent.trim();
    if(actual === expected[i]){
      c.classList.remove('incorrect'); c.classList.add('correct');
    } else {
      c.classList.remove('correct'); c.classList.add('incorrect');
      allCorrect = false;
    }
  });
  if(allCorrect){
    messageEl.textContent = 'All correct — great job!';
    messageEl.style.color = '#0b7';
  } else {
    messageEl.textContent = 'Some lines are in the wrong order. Incorrect blocks are highlighted.';
    messageEl.style.color = '#b33';
  }
}

// reveal hint: find an expected position that is wrong and place a matching block (by text)
function revealHint(){
  const used = usedHintsCount[current] || 0;
  if(used >= MAX_HINTS_PER_PUZZLE){
    messageEl.textContent = `No hints left for this puzzle (max ${MAX_HINTS_PER_PUZZLE}).`;
    messageEl.style.color = '#a00';
    updateRevealHintBtn();
    return;
  }
  const p = fullPuzzles[current];
  const expected = p.lines.map(s => s.trim());
  const children = Array.from(codeBox.children);

  // find indices where the current text doesn't match expected
  const wrongPositions = [];
  children.forEach((c, idx) => {
    if(c.textContent.trim() !== expected[idx]) wrongPositions.push(idx);
  });
  if(wrongPositions.length === 0){
    messageEl.textContent = 'All lines are already correct.';
    messageEl.style.color = '#444';
    return;
  }

  // pick a random wrong position
  const targetPos = wrongPositions[Math.floor(Math.random()*wrongPositions.length)];
  const neededText = expected[targetPos];

  // find a block elsewhere whose text equals neededText
  const candidate = children.find((c, idx) => idx !== targetPos && c.textContent.trim() === neededText);
  if(candidate){
    // move candidate into targetPos
    const remaining = Array.from(codeBox.children).filter(n => n !== candidate);
    if(targetPos >= remaining.length) codeBox.appendChild(candidate);
    else codeBox.insertBefore(candidate, remaining[targetPos]);
    candidate.classList.remove('incorrect'); candidate.classList.add('correct');
    usedHintsCount[current] = used + 1;
    messageEl.textContent = `Hint used: one line placed correctly (${usedHintsCount[current]} of ${MAX_HINTS_PER_PUZZLE}).`;
    messageEl.style.color = '#0b5';
    updateRevealHintBtn();
    return;
  }

  // fallback: if no matching-text block found (shouldn't happen), fallback to original behavior using origIndex
  const eligible = [];
  children.forEach((c, idx) => {
    const orig = Number(c.dataset.origIndex);
    if(orig !== idx) eligible.push({el:c, orig});
  });
  if(eligible.length === 0){
    messageEl.textContent = 'All lines are already correct.';
    messageEl.style.color = '#444';
    return;
  }
  const choice = eligible[Math.floor(Math.random()*eligible.length)];
  const block = choice.el;
  const origPos = choice.orig;
  const remaining = Array.from(codeBox.children).filter(n => n !== block);
  if(origPos >= remaining.length) codeBox.appendChild(block);
  else codeBox.insertBefore(block, remaining[origPos]);
  block.classList.remove('incorrect'); block.classList.add('correct');
  usedHintsCount[current] = used + 1;
  messageEl.textContent = `Hint used: one line placed correctly (${usedHintsCount[current]} of ${MAX_HINTS_PER_PUZZLE}).`;
  messageEl.style.color = '#0b5';
  updateRevealHintBtn();
}

function updateRevealHintBtn(){
  const used = usedHintsCount[current] || 0;
  const left = Math.max(0, MAX_HINTS_PER_PUZZLE - used);
  if(left <= 0){
    revealHintBtn.disabled = true;
    revealHintBtn.textContent = `Reveal hint (used up)`;
    revealHintBtn.style.opacity = '0.6';
  } else {
    revealHintBtn.disabled = false;
    revealHintBtn.textContent = `Reveal hint (${left} left)`;
    revealHintBtn.style.opacity = '1';
  }
}

function resetPuzzle(){
  usedHintsCount[current] = usedHintsCount[current] || 0;
  buildCodeBox(current);
}

function nextPuzzle(){
  current = (current + 1) % fullPuzzles.length;
  puzzleSelect.value = current;
  loadPuzzle(current);
}

function loadPuzzle(idx){
  current = idx;
  puzzleSelect.value = idx;
  renderDescription(idx);
  buildCodeBox(idx);
  messageEl.textContent = '';
  if(pickedBlock){ pickedBlock.style.outline=''; pickedBlock=null; }
}

// init: register container-level drag handlers only once
function init(){
  populatePuzzleSelect();
  renderDescription(0);
  buildCodeBox(0);

  submitBtn.addEventListener('click', checkOrder);
  revealHintBtn.addEventListener('click', revealHint);
  resetBtn.addEventListener('click', resetPuzzle);
  nextBtn.addEventListener('click', nextPuzzle);
  puzzleSelect.addEventListener('change', e => loadPuzzle(Number(e.target.value)));

  // container-level dragover/drop
  codeBox.addEventListener('dragover', e => {
    e.preventDefault();
    const draggedId = e.dataTransfer.getData('text/plain');
    if (!draggedId) return;
    const draggedEl = codeBox.querySelector(`[data-id="${draggedId}"]`);
    if (!draggedEl) return;
    const afterEl = getDragAfterElement(codeBox, e.clientY);
    if (afterEl == null) {
      if (codeBox.lastElementChild !== draggedEl) codeBox.appendChild(draggedEl);
    } else {
      if (afterEl !== draggedEl.previousElementSibling) codeBox.insertBefore(draggedEl, afterEl);
    }
  });
  codeBox.addEventListener('drop', e => { e.preventDefault(); });

  // keyboard accessibility: focus handling + arrow keys for moving blocks
  codeBox.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      const first = codeBox.querySelector('.block');
      if(first) first.focus();
      return;
    }
    const focused = document.activeElement;
    if (!focused || !focused.classList || !focused.classList.contains('block')) return;
    if (e.key === 'ArrowUp'){
      e.preventDefault();
      const prev = focused.previousElementSibling;
      if (prev) codeBox.insertBefore(focused, prev);
      focused.focus();
    } else if (e.key === 'ArrowDown'){
      e.preventDefault();
      const next = focused.nextElementSibling;
      if (next) codeBox.insertBefore(next, focused);
      focused.focus();
    }
  });

  updateRevealHintBtn();
}

init();

</script>
</body>
</html>
