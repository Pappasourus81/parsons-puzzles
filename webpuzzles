<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Parsons Code Checker â€” Reorder Mode</title>
  <style>
    :root{
      --gap: 12px;
      --card-bg: #f8f9fb;
      --slot-border: #ccccd6;
      --ok: #d4f7d9;
      --bad: #ffd6d6;
      --accent: #0066cc;
    }
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin: 18px;
      background: #ffffff;
      color:#111;
    }
    h1{ margin: 0 0 14px 0; font-size: 20px; }
    .controls{ display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; align-items:center }
    button{
      background:var(--accent);
      color:white;
      border: none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:14px;
    }
    button.secondary{ background:#666; }
    .layout{
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
      align-items:start;
    }
    .panel{
      background:var(--card-bg);
      padding:12px;
      border-radius:10px;
      box-shadow: 0 2px 6px rgba(10,10,20,0.03);
    }
    .puzzle-box{
      margin:10px 0 12px 0;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #d1d7df;
      background:#ffffff; /* keep clean white */
      box-shadow:0 1px 3px rgba(10,10,20,0.04);
      font-size:14px;
      font-weight:600;
      color:#222;
    }
    .scrambled-box{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:10px;
      border: 2px dashed var(--slot-border);
      min-height: 120px;
      border-radius:8px;
      background: #fff;
    }
    .piece{
      padding:8px 10px;
      background:white;
      border-radius:6px;
      box-shadow:0 1px 2px rgba(0,0,0,0.05);
      cursor:grab;
      user-select:none;
      white-space:pre-wrap;
      font-family: "Courier New", monospace;
      font-size: 13px;
      border:1px solid transparent;
      transition: transform 200ms ease, background-color 200ms ease, border-color 200ms ease;
    }
    .piece.dragover{ outline:2px dashed #0066cc; }
    .piece.picked{ transform: scale(1.02); box-shadow:0 4px 10px rgba(0,0,0,0.08); }
    .swap-anim {
      animation: swapFlash 280ms ease;
    }
    @keyframes swapFlash {
      0% { transform: translateY(0) scale(1); }
      25% { transform: translateY(-6px) scale(1.02); }
      60% { transform: translateY(2px) scale(.995); }
      100% { transform: translateY(0) scale(1); }
    }
    .message{ margin-top:10px; font-weight:600; }
    .meta{ font-size:14px; color:#444; margin-bottom:8px; }
    .description{ font-size:13px; color:#666; margin-left:6px }
    @media (max-width:900px){
      .layout{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Parsons Code Checker â€” Reorder Mode</h1>
  <div style="display:flex; gap:12px; align-items:flex-start;">
    <div class="meta">Drag lines to reorder them. Drop a line onto another to swap places. Submit to check.</div>
  </div>

  <div class="controls">
    <button id="submitBtn">Submit</button>
    <button id="resetBtn" class="secondary">Reset (reshuffle)</button>
    <button id="nextBtn">New Puzzle</button>
    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <label style="font-size:13px; color:#333">Puzzle:
        <select id="puzzleSelect" style="margin-left:6px; padding:6px; border-radius:6px;"></select>
      </label>
    </div>
  </div>

  <!-- Description box placed here, above the scrambled code -->
  <div class="puzzle-box" id="puzzleDescription">Select a puzzle to see its description.</div>

  <div class="layout">
    <div class="panel">
      <strong>Scrambled code (reorder here)</strong>
      <div id="scrambled" class="scrambled-box" aria-label="scrambled code lines"></div>
      <div id="message" class="message" role="status"></div>
    </div>
  </div>

<script>
/* Reorder mode with swap animation
   - Description box now appears above the scrambled area (styled).
   - Small animation plays on swapped pieces for visual feedback.
*/
const puzzles = [
  {
    title: "Basic IF (Pseudocode)",
    description: "Asks the user for a number and outputs that the number is positive if it is greater than zero.",
    lines: [
      "BEGIN",
      "    OUTPUT \"Enter a number: \"",
      "    INPUT number",
      "    IF number > 0 THEN",
      "        OUTPUT \"The number is positive\"",
      "    ENDIF",
      "END"
    ]
  },
  {
    title: "IF-ELSE (Pseudocode)",
    description: "Reads a number and outputs whether it is even or odd using the MOD operator.",
    lines: [
      "BEGIN",
      "    OUTPUT \"Enter a number: \"",
      "    INPUT number",
      "    IF number MOD 2 = 0 THEN",
      "        OUTPUT \"The number is even\"",
      "    ELSE",
      "        OUTPUT \"The number is odd\"",
      "    ENDIF",
      "END"
    ]
  },
  {
    title: "Nested IF (Pseudocode)",
    description: "Checks whether a number is positive, and if so, whether it is greater than 100 â€” outputs a different message for large vs small positive numbers.",
    lines: [
      "BEGIN",
      "    OUTPUT \"Enter a number: \"",
      "    INPUT number",
      "    IF number > 0 THEN",
      "        IF number > 100 THEN",
      "            OUTPUT \"The number is large and positive\"",
      "        ELSE",
      "            OUTPUT \"The number is small but positive\"",
      "        ENDIF",
      "    ENDIF",
      "END"
    ]
  },
  {
    title: "Nested IF with ELSE (Pseudocode)",
    description: "Classifies a number as large positive, small positive, negative, or zero using nested IF/ELSE blocks.",
    lines: [
      "BEGIN",
      "    OUTPUT \"Enter a number: \"",
      "    INPUT number",
      "    IF number > 0 THEN",
      "        IF number > 100 THEN",
      "            OUTPUT \"The number is large and positive\"",
      "        ELSE",
      "            OUTPUT \"The number is small but positive\"",
      "        ENDIF",
      "    ELSE",
      "        IF number < 0 THEN",
      "            OUTPUT \"The number is negative\"",
      "        ELSE",
      "            OUTPUT \"The number is zero\"",
      "        ENDIF",
      "    ENDIF",
      "END"
    ]
  }
];

let currentIndex = 0;
let currentOrder = []; // mutable array of lines in current scrambled order
const scrambledEl = document.getElementById('scrambled');
const messageEl = document.getElementById('message');
const puzzleSelect = document.getElementById('puzzleSelect');
const puzzleDescriptionEl = document.getElementById('puzzleDescription');

// populate dropdown
puzzles.forEach((p, i) => {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = `${i+1}. ${p.title}`;
  puzzleSelect.appendChild(opt);
});

puzzleSelect.addEventListener('change', e => {
  currentIndex = parseInt(e.target.value, 10);
  loadPuzzle(currentIndex);
});

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function renderScrambled() {
  scrambledEl.innerHTML = '';
  currentOrder.forEach((line, idx) => {
    const el = document.createElement('div');
    el.className = 'piece';
    el.draggable = true;
    el.dataset.index = idx;
    el.dataset.line = line;
    el.textContent = line;

    // dragstart stores the index
    el.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', idx);
      e.dataTransfer.effectAllowed = 'move';
      // mark source for keyboard/touch clarity
      el.classList.add('picked');
    });

    el.addEventListener('dragend', () => el.classList.remove('picked'));

    el.addEventListener('dragover', (e) => {
      e.preventDefault();
      el.classList.add('dragover');
    });
    el.addEventListener('dragleave', () => el.classList.remove('dragover'));

    el.addEventListener('drop', (e) => {
      e.preventDefault();
      el.classList.remove('dragover');
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'), 10);
      const toIdx = parseInt(el.dataset.index, 10);
      if (!Number.isNaN(fromIdx) && !Number.isNaN(toIdx) && fromIdx !== toIdx) {
        swapItems(fromIdx, toIdx);
        // add a small animation class to both swapped elements
        renderScrambled();
        // find the two elements and animate
        setTimeout(() => {
          const children = Array.from(scrambledEl.children);
          const a = children[toIdx];
          const b = children[fromIdx];
          if (a) { a.classList.add('swap-anim'); setTimeout(()=>a.classList.remove('swap-anim'), 300); }
          if (b) { b.classList.add('swap-anim'); setTimeout(()=>b.classList.remove('swap-anim'), 300); }
        }, 10);
      }
    });

    // click-to-swap behaviour for touch/keyboard: select one then another
    el.addEventListener('click', () => {
      const prev = scrambledEl.querySelector('.picked');
      if (prev && prev !== el) {
        const i1 = parseInt(prev.dataset.index,10);
        const i2 = parseInt(el.dataset.index,10);
        swapItems(i1,i2);
        prev.classList.remove('picked');
        renderScrambled();
        // animate
        setTimeout(()=>{
          const children = Array.from(scrambledEl.children);
          const a = children[i1];
          const b = children[i2];
          if (a) { a.classList.add('swap-anim'); setTimeout(()=>a.classList.remove('swap-anim'), 300); }
          if (b) { b.classList.add('swap-anim'); setTimeout(()=>b.classList.remove('swap-anim'), 300); }
        },10);
      } else {
        // mark this as picked
        scrambledEl.querySelectorAll('.picked').forEach(x=>x.classList.remove('picked'));
        el.classList.add('picked');
      }
    });

    scrambledEl.appendChild(el);
  });
}

function swapItems(i, j) {
  const tmp = currentOrder[i];
  currentOrder[i] = currentOrder[j];
  currentOrder[j] = tmp;
}

function resetPuzzle() {
  const puzzle = puzzles[currentIndex];
  currentOrder = puzzle.lines.slice();
  shuffle(currentOrder);
  renderScrambled();
  messageEl.textContent = '';
}

function submitPuzzle() {
  const puzzle = puzzles[currentIndex];
  const correct = puzzle.lines;
  let allCorrect = true;
  const pieces = Array.from(scrambledEl.children);
  pieces.forEach((p, i) => {
    p.style.background = '';
    p.style.borderColor = '';
    const text = p.dataset.line.trim();
    if (text === correct[i].trim()) {
      p.style.background = 'var(--ok)';
      p.style.borderColor = '#2a9a4a';
    } else {
      p.style.background = 'var(--bad)';
      p.style.borderColor = '#c44';
      allCorrect = false;
    }
  });
  if (allCorrect) {
    messageEl.textContent = 'All correct! Well done ðŸŽ‰';
    messageEl.style.color = '#1a7f3a';
  } else {
    messageEl.textContent = 'Some lines are incorrect â€” incorrect lines are highlighted.';
    messageEl.style.color = '#a00';
  }
}

function nextPuzzle() {
  currentIndex = (currentIndex + 1) % puzzles.length;
  puzzleSelect.value = currentIndex;
  loadPuzzle(currentIndex);
}

function loadPuzzle(index) {
  currentIndex = index;
  puzzleDescriptionEl.textContent = puzzles[index].description || '';
  resetPuzzle();
}

// wire buttons
document.getElementById('submitBtn').addEventListener('click', submitPuzzle);
document.getElementById('resetBtn').addEventListener('click', resetPuzzle);
document.getElementById('nextBtn').addEventListener('click', nextPuzzle);

// initial load
puzzleSelect.value = 0;
loadPuzzle(0);
</script>
</body>
</html>
